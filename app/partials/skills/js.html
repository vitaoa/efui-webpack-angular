
<!--div.mlist>((div.mtit>span)+div.mcon>ol>li>a)-->
<!--div.mswitch>(div.pt10.pb10+div.example-visualize)-->

<div class="mlist" expander>
	<div class="mtit" ng-click="toggleanswer()"><span>目录</span></div>
	<div class="mcon">
		<ol ng-show="answershow">
			<li><a href="">宿主环境</a></li>
			<li>
				<a href="">函数调用</a>
			</li>
			<li>
				<a href="">立即执行函数</a>
			</li>
			<li>
				<a href="">数据类型判断</a>
			</li>
			<li>
				<a href="">容易混淆的client-*,scroll-*,offset-*</a>
			</li>
			<li>
				<a href="">namespace命名空间</a>
			</li>
			<li>
				<a href="">两种继承方式call和apply</a>
			</li>
			<li>
				<a href="">使定时器settimeout、setInterval能够执行带参数的函数</a>
			</li>
			<li>
				<a href="">JS类的封装及实现</a>
			</li>
			<li>
				<a href="">JS事件</a>
			</li>
			<li>
				<a href="">JS继承</a>
			</li>
			<li>
				<a href="">JS赋值运算</a>
			</li>
			<li>
				<a href="">IE浏览器专属</a>
			</li>
		</ol>
	</div>
</div>

<div class="mswitch">
	<ol class="hanja">
		<li>
			<p>console对象，window对象，DOM元素对象并不被javaScript真正“拥有”</p>
			<ol class="decimal">
				<li>console对象：
					<b class="c-red">console对象并不是属于JS的而是浏属于浏览器的</b>。因此， 各大浏览器关于console对象API的实现也各不相同
				</li>
				<li>window对象：保存全局变量的顶层对象
					<p><b>与Global对象的区别：</b></p>
					<ul>
						<li>Global对象是ECMAscript标准中定死的全局对象</li>
						<li>Window对象是浏览器的一个实例，</li>
					</ul>
				</li>
				<li>DOM元素对象：是浏览器提供的东西，有如下特点：
					<ul>
						<li>无法写覆盖；</li>
						<li>包含一些预定义的只读属性；</li>
						<li>包含无法将 this 重载为其他对象的方法。</li>
					</ul>
				</li>
			</ol>
		</li>
		<li>
			<p>javascript一般是不能独立运行的， 而要依赖于宿主环境，常见的宿主环境有：</p>
			<ol class="decimal">
				<li>浏览器 (最常见)</li>
				<li>node</li>
			</ol>
		</li>
		<li><b>js的this</b>
			<ul>
				<li>严格模式下('use strict';),没有宿主调用的函数中的this是undefined</li>
			</ul>
		</li>
	</ol>
</div>
<div class="mswitch">
	<div class="pt10 pb10">函数调用</div>
	<div class="example-desc">
		<div class="exm-t2">
			<p>js里函数调用有4种模式：方法调用、正常函数调用、构造器函数调用、apply/call 调用；</p>
			<p>无论哪种函数调用除了你声明时定义的形参外，还会自动添加2个形参，分别是 this 和 arguments；</p>
			<p>this 的值，在上面4种调用模式下，分别会绑定不同的值：</p>
		</div>
		<ol class="decimal mt10">
			<li>方法调用：(函数是一个对象的属性)
				<div class="html">
					<pre>var a = {
    v : 0,
    f : function(xx) {
        this.v = xx;
    }
}
a.f(5);</pre>
					这个时候，上面函数里的 this 就绑定的是这个对象 a。所以 this.v 可以取到对象 a 的属性 v。
				</div>
			</li>
			<li>正常函数调用：
				<div class="html">
					<pre>function f(xx) {
    this.x = xx;
}
f(5);</pre>
					这个时候，函数 f 里的 this 绑定的是全局对象，如果是在浏览器运行的解释器中，一般来说是 window 对象，如果 window 没有 x 属性，就给 window 对象添加了一个 x 属性，同时赋值。
				</div>
			</li>
			<li>构造器函数调用：
				<div class="html">
					<pre>function a(xx) {
    this.m = xx;
}
var b = new a(5);</pre>
					如果你在一个函数前面带上 new 关键字来调用，那么 js 会创建一个 prototype 属性是此函数的一个新对象，同时在调用这个函数的时候，把 this 绑定到这个新对象上。
					<span class="c-red">在 jslint 里，它会要求你写的所有构造函数，也就是一旦它发现你用了 new 关键字，那么后面那个函数的首字母必须大写。</span>
				</div>
			</li>
			<li>apply/call 调用：
				<div class="html">
					<pre>function a(xx) {
    this.b = xx;
}
var o = {};
a.apply(o, [5]);
alert(a.b);    // undefined
alert(o.b);    // 5</pre>
					每个函数都拥有 apply()、call() 这个方法，可以用来设置 this 的值。
					<span class="c-red">因为在 js 里所有的函数都有一个共同的 prototype，也就是传说中的 Function.prototype, 这个原型里有两个神奇的方法，一个就是这里的 apply ，另一个就是让题主疑惑的 call</span>
				</div>
			</li>
		</ol>
	</div>
</div>
<div class="mswitch">
	<h3 class="mb10">一、立即执行函数 </h3>
	<div class="example-demo">
		<pre>(function(){…}) ()
(function(){…} ())</pre>
	</div>
	<div class="example-desc">
		<div class="exm-t1"><b>要理解立即执行函数，需要先理解一些函数的基本概念。</b></div>
		<ul>
			<li><b>函数声明</b>
				<ul>
					<li>函数声明：function fnName () {…};使用function关键字声明一个函数，再指定一个函数名，叫函数声明。</li>
				</ul>
			</li>
			<li><b>函数表达式</b>
				<ul>
					<li>函数表达式 var fnName = function () {…};使用function关键字声明一个函数，但未给函数命名，最后将匿名函数赋予一个变量，叫函数表达式，这是最常见的函数表达式语法形式。</li>
				</ul>
			</li>
			<li><b>匿名函数</b>
				<ul>
					<li>匿名函数：function () {}; 使用function关键字声明一个函数，但未给函数命名，所以叫匿名函数，匿名函数属于函数表达式，匿名函数有很多作用，赋予一个变量则创建函数，赋予一个事件则成为事件处理程序或创建闭包等等。</li>
				</ul>
			</li>
		</ul>
		<div class="exm-t2"><b>函数声明和函数表达式的不同之处：</b></div>
		<ol>
			<li>Javascript引擎在解析javascript代码时会“函数声明提升”（Function declaration Hoisting）当前执行环境（作用域）上的函数声明，而函数表达式必须等到Javascirtp引擎执行到它所在行时，才会从上而下一行一行地解析函数表达式；</li>
			<li>函数表达式后面可以加括号立即调用该函数，函数声明不可以，只能以fnName()形式调用。</li>
			<li>函数调用可在函数声明之前，但是必须在函数表达式之后</li>
		</ol>
		<pre>var fnName=function(){
    alert('Hello World');
}();
//函数表达式后面加括号，当javascript引擎解析到此处时能立即调用函数
function fnName(){
    alert('Hello World');
}();
//不会报错，但是javascript引擎只解析函数声明，忽略后面的括号，函数声明不会被调用
function(){
    console.log('Hello World');    
}();
//语法错误，虽然匿名函数属于函数表达式，但是未进行赋值操作，
//所以javascript引擎将开头的function关键字当做函数声明，报错：要求需要一个函数名</pre>
		<div class="exm-t2"><b>总结：</b></div>
		<ol>
			<li><span class="red">要在函数体后面加括号就能立即调用，则这个函数必须是函数表达式</span>，不能是函数声明；</li>
			<li><span class="c-red">（）、！、+、-、=等运算符，都将函数声明转换成函数表达式</span>，消除了javascript引擎识别函数表达式和函数声明的歧义，告诉javascript引擎这是一个函数表达式，不是函数声明，可以在后面加括号，并立即执行函数的代码；</li>
			<li><span class="red">加括号是最安全的做法</span>，因为！、+、-等运算符还会和函数的返回值进行运算，有时造成不必要的麻烦。</li>
		</ol>
		<pre>(function(a){
    console.log(a);   //firebug输出123,使用（）运算符
})(123);

(function(a){
    console.log(a);   //firebug输出1234，使用（）运算符
}(1234));

!function(a){
    console.log(a);   //firebug输出12345,使用！运算符
}(12345);

+function(a){
    console.log(a);   //firebug输出123456,使用+运算符
}(123456);

-function(a){
    console.log(a);   //firebug输出1234567,使用-运算符
}(1234567);

var fn=function(a){
    console.log(a);   //firebug输出12345678，使用=运算符
}(12345678)</pre>
	</div>
</div>

<div class="mswitch">
	<div class="pt10 pb10">数据类型判断</div>
	<div class="example-desc">
		例子：
		<div class="html">
			<pre>var a = "iamstring.";
var b = 222;
var c= [1,2,3];
var d = new Date();
var e = function(){alert(111);};
var f = function(){this.name="22";};　　</pre>
		</div>
		<ol class="hanja">
			<li>typeof：
				<ol class="decimal">
					<li>最常见的判断方法
						<div class="html">
							<pre>console.log(typeof a)  ------------> string
console.log(typeof b)  ------------> number
console.log(typeof c)  ------------> object
console.log(typeof d)  ------------> object
console.log(typeof e)  ------------> function
console.log(typeof f)  ------------> function</pre>
							<!--<script>-->
                            <!--var a = "iamstring.";-->
                            <!--var b = 222;-->
                            <!--var c= [1,2,3];-->
                            <!--var d = new Date();-->
                            <!--var e = function(){alert(111);};-->
                            <!--var f = function(){this.name="22";};-->
                           	<!--console.log(typeof a);-->
                            <!--console.log(typeof b);-->
                            <!--console.log(typeof c);-->
                            <!--console.log(typeof d);-->
                            <!--console.log(typeof e);-->
                            <!--console.log(typeof f);-->
							<!--</script>-->
						</div>
					</li>
					<li>返回的类型都是字符串形式
						<div class="html">
							<pre>console.log(typeof a == "string") -------------> true
console.log(typeof a == String) ---------------> false</pre>
							<!--<script>-->
                                <!--var a = "iamstring.";-->
                                <!--console.log(typeof a == "string");-->
                                <!--console.log(typeof a == String)-->
							<!--</script>-->
						</div>
					</li>
					<li>可以判断function的类型，在<span class="c-red">判断<b>除Object类型</b>的对象时比较方便</span></li>
				</ol>
			</li>
			<li>instanceof：
				<ol class="decimal">
					<li>判断已知对象类型的方法，<span class="c-red">后面一定要是对象类型，并且大小写不能错</span>
						<div class="html">
							<pre>console.log(c instanceof Array) ---------------> true
console.log(d instanceof Date)
console.log(f instanceof Function) ------------> true
console.log(f instanceof function) ------------> false</pre>
							<!--<script>-->
                                <!--var a = "iamstring.";-->
                                <!--var b = 222;-->
                                <!--var c= [1,2,3];-->
                                <!--var d = new Date();-->
                                <!--var e = function(){alert(111);};-->
                                <!--var f = function(){this.name="22";};-->
                                <!--console.log(c instanceof Array);-->
                                <!--console.log(d instanceof Date);-->
                                <!--console.log(f instanceof Function);-->
<!--//                                console.log(f instanceof function);-->
							<!--</script>-->
						</div>
					</li>
				</ol>
			</li>
			<li>constructor：
				<ol class="decimal">
					<li>根据对象的constructor判断
                        <div class="html">
                            <pre>console.log(c.constructor === Array) ----------> true
console.log(d.constructor === Date) -----------> true
console.log(e.constructor === Function) -------> true</pre>
                        </div>
                        <!--<script>-->
                        <!--var a = "iamstring.";-->
                        <!--var b = 222;-->
                        <!--var c= [1,2,3];-->
                        <!--var d = new Date();-->
                        <!--var e = function(){alert(111);};-->
                        <!--var f = function(){this.name="22";};-->
                        <!--console.log(c.constructor === Array);-->
                        <!--console.log(d.constructor === Date);-->
                        <!--console.log(e.constructor === Function);-->
                        <!--</script>-->
                    </li>
                    <li><span class="c-red">constructor 在类继承时会出错</span>
                        <div class="html">
                            <pre>function A(){};
function B(){};
A.prototype = new B(); //A继承自B
var aObj = new A();
console.log(aObj.constructor === B) -----------> true;
console.log(aObj.constructor === A) -----------> false;</pre>
                        </div>
                        <!--<script>-->
                            <!--function A(){};-->
                            <!--function B(){};-->
                            <!--A.prototype = new B(); //A继承自B-->
                            <!--var aObj = new A();-->
                            <!--console.log(aObj.constructor === B);-->
                            <!--console.log(aObj.constructor === A);-->
                        <!--</script>-->
                        <div class="c-red">而instanceof方法不会出现该问题，对象直接继承和间接继承的都会报true：</div>
                        <div class="html">
                            <pre>console.log(aObj instanceof B) ----------------> true;
console.log(aObj instanceof B) ----------------> true;</pre>
                        </div>
                    </li>
				</ol>
			</li>
			<li>prototype：
				<ol class="decimal">
					<li>通用但很繁琐的方法，<span class="c-red">大小写不能写错</span>
						<div class="html">
							<pre>console.log(Object.prototype.toString.call(a) === '[object String]') -------> true;
console.log(Object.prototype.toString.call(b) === '[object Number]') -------> true;
console.log(Object.prototype.toString.call(c) === '[object Array]') -------> true;
console.log(Object.prototype.toString.call(d) === '[object Date]') -------> true;
console.log(Object.prototype.toString.call(e) === '[object Function]') -------> true;
console.log(Object.prototype.toString.call(f) === '[object Function]') -------> true;
</pre>
						</div>
						<script>
							var a = "iamstring.";
							var b = 222;
							var c= [1,2,3];
							var d = new Date();
							var e = function(){alert(111);};
							var f = function(){this.name="22";};
                            console.log(Object.prototype.toString.call(a) === '[object String]');
                            console.log(Object.prototype.toString.call(b) === '[object Number]');
                            console.log(Object.prototype.toString.call(c) === '[object Array]');
                            console.log(Object.prototype.toString.call(d) === '[object Date]');
                            console.log(Object.prototype.toString.call(e) === '[object Function]');
                            console.log(Object.prototype.toString.call(f) === '[object Function]');
						</script>
					</li>
				</ol>
			</li>
			<li>$.type()/jQuery.type()：
				<ol class="decimal">
					<li>无敌万能的方法，<span class="c-red">如果对象是undefined或null，则返回相应的"undefined"或"null"。</span>
						<div class="html">
							<pre>jQuery.type( undefined ) === "undefined"
jQuery.type() === "undefined"
jQuery.type( window.notDefined ) === "undefined"
jQuery.type( null ) === "null"</pre>
						</div>
					</li>
					<li>如果对象有一个内部的[[Class]]和一个浏览器的内置对象的 [[Class]] 相同，我们返回相应的 [[Class]] 名字，其他一切都将返回它的类型“object”。
						<div class="html">
							<pre>jQuery.type( true ) === "boolean"
jQuery.type( 3 ) === "number"
jQuery.type( "test" ) === "string"
jQuery.type( function(){} ) === "function"
jQuery.type( [] ) === "array"
jQuery.type( new Date() ) === "date"
jQuery.type( new Error() ) === "error" // as of jQuery 1.9
jQuery.type( /test/ ) === "regexp"</pre>
						</div>
					</li>
				</ol>
			</li>
			<li>
				<b class="c-red">总结：通常情况下用typeof 判断就可以了，遇到预知Object类型的情况可以选用instanceof或constructor方法,实在没辙就使用$.type()方法。</b>
			</li>
		</ol>
	</div>
</div>
<div class="mswitch">
	<div class="pt10 pb10"></div>
	<div class="example-desc">
		分析：
		<div class="html">
			<pre>offsetWidth offsetHeight offsetLeft offsetTop
clientWidth clientHeight clientLeft clientTop
scrollWidth scrollHeight scrollLeft scrollTop</pre>
		</div>
		<ol class="hanja">
			<li>宽度：
				<ol class="decimal">
					<li>width：原本内容区宽度（width） - 滚动条宽度</li>
					<li>offsetWidth：width + 滚动条宽度 + padding + border</li>
					<li>clientWidth：width + padding</li>
					<li>scrollWidth：clientWidth + 溢出部分</li>
				</ol>
			</li>
			<li>高度：
				<ol class="decimal">
					<li>height：原本内容区高度（height）- 滚动条高度</li>
					<li>offsetHeight：height + padding + border</li>
					<li>clientHeight：height + padding </li>
					<li>scollHeight：clientHeight + 溢出部分</li>
				</ol>
			</li>
			<li>left、top：(#wrap为参照原点，设置了position:relative)
				<ol class="decimal">
					<li>offsetLeft(即元素#inner的x坐标)：(#wrap.width - #inner.offsetWidth)/2</li>
					<li>offsetTop(即元素#inner的y坐标)：style.marginTop</li>
					<li>clientLeft(即 border-left-width)：style.borderLeftWidth</li>
					<li>clientTop(即 border-top-width)：style.borderTopWidth</li>
					<li>scrollLeft：水平方向滚动条</li>
					<li>scrollTop：滚动条离#inner border-top内侧的位置，一开始为0</li>
				</ol>
			</li>
			<li>结论：
				<p class="c-red">scrollWidth & scrollHeight：如果没有溢出时，这些属性与clientWidth和clientHeight是相等的</p>
			</li>
		</ol>
	</div>
</div>

<div class="mswitch">
	<h3 class="mb10">二、namespace命名空间 </h3>
	<div class="example-demo">
		<pre>/**
* 创建全局对象MYAPP
* @module MYAPP
* @title MYAPP Global
*/
var MYAPP = MYAPP || {};

/**
* 返回指定的命名空间，如果命名空间不存在则创建命名空间。
* 备注：命名时需小心，注意保留关键字，可能在一些浏览器无法使用。
*
* @method namespace
* @param {String *} 至少需要创建一个命名空间
* @return {Object} 最后一个命名空间创建的对象的引用
*/
MYAPP.namespace = function(str){
    var parts = str.split("."),
    parent = MYAPP,
    i=0,
    l=0;

    if(parts[0]==="MYAPP"){
        parts = parts.slice(1);
    }
    for(i=0,l=parts.length; i < l;i++){
        if(typeof parent[parts[i]] === "undefined"){
            parent[parts[i]] = {};
        }
        parent = parent[parts[i]];
    }
    return parent;
}

/**
* bfun是Basic Functions Extended的缩写
* 作用：包括数组、字符串等等数功能扩展
*
* @module bfun
*/
MYAPP.bfun = {
    array:(function(){
        return {
            /**
            * @method isArray 判断是否为数组
            * @param {Array} 数组
            * @return {Boolean} 真返回true，否则返回false
            */
            isArray: function(){
                return Object.prototype.toString.call(arguments[0])  === '[object Array]'; 
            },
            /**
            * @method inArray 检查值是否在数组中
            * @param {value，Array} 值，数组
            * @return {Boolean} 真返回true，否则返回undefined
            */
            inArray: function(val,arr){
                for(var i=0,l=arr.length;i < l;i++){
                    if(arr[i] === val){
                        return true;
                    }
                }
            }
        }
    })(),
    string:(function(){
        return {
            /**
            * @method trim 过滤字符串两边多余的空格
            * @param {String} 字符串
            * @return {String} 字符串
            */
            trim: function(){
                return arguments[0].replace(/(^\s*)|(\s*$)/g, "");
            },
            /**
            * @method ltrim 过滤字符串左边多余的空格
            * @param {String} 字符串
            * @return {String} 字符串
            */
            ltrim: function(){
                return arguments[0].replace(/^s+/g, "");
            },
            /**
            * @method rtrim 过滤字符串右边多余的空格
            * @param {String} 字符串
            * @return {String} 字符串
            */
            rtrim: function(){
                return arguments[0].replace(/s+$/g, "");
            }
        }
    })()
}

// 测试
MYAPP.test = {
    init: function(){
        // 使用对应的模块先引用
        var marray = MYAPP.namespace("MYAPP.bfun.array");
        var mstring = MYAPP.namespace("MYAPP.bfun.string");

        var arr =  ["a","b"];
        var str = "   abc  ";

        console.log("判断是否为数组：" + marray.isArray(arr));
        console.log("值是否在数组中：" + marray.inArray("a",arr));
        console.log("过滤左右空格：" + mstring.trim(str));
    }
}

MYAPP.test.init();</pre>
	</div>
	<div class="example-desc">
		<div class="exm-t2">命名空间有助于减少程序中所需要的全局变量的数量，并且同时有助于避免命名冲突或过长的名字前缀。当使用多个js库文件时，为了避免在调用时不同js库文件的同名函数的冲突，一般会使用命名空间来解决。</div>
		<div class="exm-t2">使用命名空间的两点原则</div>
		<ul>
			<li>唯一性：
				<ul>
					<li>挑选一个独一无二的命名空间的名字（如Google Maps在所有的标识符中都添加了G前缀），<span class="red">注意js是大小写敏感的</span>。</li>
				</ul>
			</li>
			<li>不共享：
				<ul>
					<li>不共享意味着什么都不共享；当你创建自己的$函数时你可能会与著名的库(如Prototype)中的$函数发生冲突而导致Prototype中的$无法使用，为了不与著名的一些库（jQuery、prototype）或者其他已有的一些函数冲突，使用匿名函数来实现代码的不共享。
						<pre>(function($){
     //code
})(jQuery);</pre>这样定义了一个命名空间就不怕，js库有冲突</li>
				</ul>
			</li>
		</ul>
		<div class="exm-t2">参考一下jQuery源码结构：</div>
		<pre>(function( window, undefined ) {
   
    var jQuery = (function() {
       // 构建jQuery对象
       var jQuery = function( selector, context ) {
           return new jQuery.fn.init( selector, context, rootjQuery ); //构造函数
       }
   
       // jQuery对象原型
       jQuery.fn = jQuery.prototype = {
           constructor: jQuery,
           init: function( selector, context, rootjQuery ) {
              // selector有以下7种分支情况：
              // DOM元素
              // body（优化）
              // 字符串：HTML标签、HTML字符串、#id、选择器表达式
              // 函数（作为ready回调函数）
              // 最后返回伪数组
           }
       };
   
      //把jQuery的prototype赋值给init方法的prototype
       jQuery.fn.init.prototype = jQuery.fn;
   
       // 合并内容到第一个参数中，后续大部分功能都通过该函数扩展
       // 通过jQuery.fn.extend扩展的函数，大部分都会调用通过jQuery.extend扩展的同名函数
       jQuery.extend = jQuery.fn.extend = function() {};
      
       // 在jQuery上扩展静态方法
       jQuery.extend({
           // ready bindReady
           // isPlainObject isEmptyObject
           // parseJSON parseXML
           // globalEval
           // each makeArray inArray merge grep map
           // proxy
           // access
           // uaMatch
           // sub
           // browser
       });

       return jQuery;
   
    })();
   
    window.jQuery = window.$ = jQuery;
})(window);</pre>
		<ol>
			<li>将window对象传入匿名函数，使匿名函数内部可以直接访问，防止匿名函数内部使用window对象的时候需要层层查找作用域链，最后才能找到window</li>
			<li>没有一棍子打死，完全使用$，当出现$命名冲突的时候可以使用jQuery代替</li>
			<li>定义jQuery.fn=jQuery.prototype，代码写起来方便了很多，也有利于压缩</li>
			<li>没有使用elements属性，而是利用数组特性封装搜索结果集，在使用的时候更容易想到</li>
			<li>定义each函数用于遍历结果集</li>
			<li>提供extend函数用于向对象内部添加属性</li>
		</ol>
	</div>
</div>
<div class="mswitch">
	<h3 class="mb10">两种继承方式call和apply</h3>
	<div class="example-demo">
		<pre>Function.prototpe.apply(instance,args)  //args 数组
Function.prototpe.call(instance,a1,a2)  //a1,a2 单个参数</pre>
	</div>
	<div class="example-desc">
		<ol>
			<li>定义：
				<ul>
					<li>apply:方法能劫持另外一个对象的方法，继承另外一个对象的属性
						<ul>
							<li>Function.apply(obj,args)方法能接收两个参数</li>
							<li>obj：这个对象将代替Function类里this对象</li>
							<li>args：这个是数组，它将作为参数传给Function（args-->arguments）</li>
						</ul>
					</li>
					<li>call:和apply的意思一样,只不过是参数列表不一样
						<ul>
							<li>Function.call(obj,[param1[,param2[,…[,paramN]]]])</li>
							<li>obj：这个对象将代替Function类里this对象</li>
							<li>params：这个是一个参数列表</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>区别:
				<ul>
					<li>两者在作用上是相同的，但两者在参数上有区别的。</li>
					<li>第一个参数都是需要调用的函数对象， call的第二个参数可以是任意类型，而apply的第二个参数必须是数组</li>
				</ul>
			</li>
			<li>
				妙用：
				<ul>
					<li>
						<h5 class="mb10">call和apply可以用来改变函数中this的指向</h5>
						<p>this表示当前对象，如果在全局范围内使用this，则指代当前页面对象window；如果在函数中使用this，则this指代什么是根据运行时此函数在什么对象上被调用。</p>
						<p class="red">【注意】：函数中的this是在运行时决定的，而不是函数定义时。</p>
						<div class="html">
							<pre>function foo() {
    console.log(this.fruit);
}

var fruit = "apple";
var obj = {
    fruit: "orange"
};

foo.apply(window); // "apple"
foo.apply(obj); // "orange"</pre>
						</div>
					</li>
					<li><h5 class="mb10">apply可以将数组作为参数传递</h5></li>
				</ul>
			</li>
			<li>
				拓展：
				<ul>
					<li>
						<h5 class="mb10">this、constructor、prototype</h5>
						<ul>
							<li>this表示当前<b>对象</b></li>
							<li>constructor始终指向创建当前对象的<b>构造函数</b>
								<div class="html">
									<pre>var arr = [1, 56, 34, 12];
console.log(arr.constructor === Array); // true

// 等价于 var foo = new Function();
var Foo = function() { };
console.log(Foo.constructor === Function); // true

// 由构造函数实例化一个obj对象
var obj = new Foo();
console.log(obj.constructor === Foo); // true

// 将上面两段代码合起来，就得到下面的结论
console.log(obj.constructor.constructor === Function); // true</pre>
								</div>
								
							</li>
							<li>每个函数都有一个默认的属性prototype，而这个prototype的constructor默认指向这个函数
								<div class="html">
									<pre>function Person(name) {
    this.name = name;
};
Person.prototype.getName = function() {
    return this.name;
};
var p = new Person("ZhangSan");

console.log(p.constructor === Person); // true
console.log(Person.prototype.constructor === Person); // true
// 将上两行代码合并就得到如下结果
console.log(p.constructor.prototype.constructor === Person); // true</pre>
								</div>
								<p>当时当我们重新定义函数的prototype时<span class="red">（注意：和上例的区别，这里不是修改而是覆盖）</span>， constructor的行为就有点奇怪了，如下示例：</p>
								<div class="html">
									<pre>function Person(name) {
    this.name = name;
};
Person.prototype = {
    getName: function() {
        return this.name;
    }
};
var p = new Person("ZhangSan");
console.log(p.constructor === Person); // false
console.log(Person.prototype.constructor === Person); // false
console.log(p.constructor.prototype.constructor === Person); // false</pre>
								</div>
								<p>为什么呢？<br>
原来是因为覆盖Person.prototype时，等价于进行如下代码操作：</p>
								<div class="html">
									<pre>Person.prototype = new Object({
								    getName: function() {
								        return this.name;
								    }
								});</pre>
								</div>
								<p>而constructor始终指向创建自身的构造函数，所以此时Person.prototype.constructor === Object <span class="red">(自身(Person.prototype))</span>，即是：</p>
								<div class="html">
									<pre>function Person(name) {
    this.name = name;
};
Person.prototype = {
    getName: function() {
        return this.name;
    }
};
var p = new Person("ZhangSan");
console.log(p.constructor === Object); // true
console.log(Person.prototype.constructor === Object); // true
console.log(p.constructor.prototype.constructor === Object); // true</pre>
								</div>
								<p>怎么修正这种问题呢？方法也很简单，重新覆盖Person.prototype.constructor即可：</p>
								<div class="html">
									<pre>function Person(name) {
    this.name = name;
};
Person.prototype = new Object({
    getName: function() {
        return this.name;
    }
});
Person.prototype.constructor = Person;
var p = new Person("ZhangSan");
console.log(p.constructor === Person); // true
console.log(Person.prototype.constructor === Person); // true
console.log(p.constructor.prototype.constructor === Person); // true</pre>
								</div>
							</li>
						</ul>
						
					</li>
				</ul>
			</li>
		</ol>
	</div>
</div>
<div class="mswitch">
	<ol class="hanja">
		<li>
			<h3 class="mb10">使定时器settimeout、setInterval能够执行带参数的函数</h3>
			
			<div class="example-desc">
				<ol class="decimal">
					<li>
						<h3>函数形式 </h3>
						<div class="html"><pre>setTimeout(hideAD,1000);使用指针形式作为参数
function hideAD(){
	$("#ad").hide();
}
</pre></div>
					</li>
					<li>
						<h3>使用字符串形式</h3>
						<div class="html"><pre>setTimeout("hideAD()",1000);
function hideAD(){
	$("#ad").hide();
}
</pre></div>
					</li>
					<li>
						<h3>借助嵌套匿名函数,返回无参函数</h3>
						<div class="html">
					<pre>window.setTimeout(helpFn("ok"), 1000);
function helpFn(pmsg) { return function() { alert(pmsg); } }</pre>
						</div>
					</li>
				</ol>
			</div>
		</li>
		<li>
			<h3 class="mb10">setInterval()方法只能够执行一次</h3>
			<div class="example-desc">
				setInterval(hideAD(),1000);此方式只能够执行一次，因为hideAD后面加括号就直接执行
				<p class="c-red">当setInterval()方法的第一个参数是字符串的时候，它是在全局作用域查找字符串中的对应方法名称。</p>
			</div>
		</li>
		<li>
			<h3 class="mb10">调入函数出错 is not defined</h3>
			<div class="example-desc">
				setInterval("hideAD()",1000); <span class="c-red">会出现：hideAD is not defined</span>
				<p>解决方法：去掉双引号和括号，直接写成：setInterval(hideAD,1000);即可</p>
			</div>
		</li>
	</ol>
</div>
<div class="mswitch">
	<h3 class="mb10">JS类的封装及实现</h3>
	<div class="example-desc">
		js并不是一种面向对向的语言, 没有提供对类的支持, 因此我们不能像在传统的语言里那样用class来定义类, 但我们可以利用js的闭包封装机制来实现js类, 我们来封装一个简单的Shape类
		<ol>
			<li>
				<h5>js类的封装</h5>
				<ol>
					<li>
						<h5>实例方法</h5>
						<div class="html">
							<pre>function ShapeBase() { 
	this.show = function() { 
		alert("ShapeBase show"); 
	}; 
	this.init = function(){ 
		alert("ShapeBase init"); 
	}; 
} </pre>
							<ul>
								<li>这个类里定义了两个方法:show和init, 需要注意的是这里用到了<b>this来声明</b>, 而不是var, 因为用var是用来定义私有方法的</li>
								<li>另外, 我们还可以用<b>prototype属性</b>来定义Shape的方法：
									<div class="html">
										<pre>var ShapeBase = function (){
										
};
ShapeBase.prototype.show=function() { 
	alert("ShapeBase show"); 
} 
ShapeBase.prototype.init=function() { 
	alert("ShapeBase init"); 
} </pre>
									</div>
								</li>
								<li>上面这种写法看起来不太直观，我们可以将所有的方法写在一起
									<div class="html">
										<pre>var ShapeBase = function (){
										
};
ShapeBase.prototype={ 
	show:function() { 
		alert("ShapeBase show"); 
	}, 
	init:function() { 
		alert("ShapeBase init"); 
	} 
}; </pre>
									</div>
								</li>
								<li>测试一下：
									<div class="html">
										<pre>ShapeBase.prototype={ 
	show:function() { 
		alert("ShapeBase show"); 
	}, 
	init:function() { 
		alert("ShapeBase init"); 
	} 
};
function test(src){ 
	var s=new ShapeBase(); 
	s.init(); 
	s.show(); 
} 
//var ShapeBase = function(){}; 等同于 function ShapeBase(){}
//前一种定义函数的方式没有名字，故而在var的后面跟上其名字，而后面function定义直接就跟了名字ShapeBase了</pre>

									</div>
								</li>
							</ul>
						</div>
					</li>
					<li>
						<h5>静态方法</h5>
						<div class="html">
							<pre>//静态方法 
function ShapeBase(){
	
}
ShapeBase.StaticDraw = function() { 
	alert("method draw is static"); 
}
ShapeBase.StaticDraw();</pre>
						</div>
					</li>
					<li>
						<h5>静态方法与实例方法的区别</h5>
						<div class="html">
							<pre>function A(){
 
}
A.staticMethod = function(){
  	alert('静态方法');
}
A.prototype.instaceMethod = function(){
  	alert('实例方法');
}
A.staticMethod();
var instace = new A();
instace.instaceMethod();</pre>
						</div>
						<ul>
							<li>静态方法是类直接调用，实例方法要new出来的对象才能调用</li>
						</ul>
					</li>
				</ol>
			</li>
			<li>
				<h5>js抽象类和继承</h5>
				<ol>
					<li>
						和类的继承一样,JavaScript也没有任何机制用于支持抽象类，但利用JavaScript语言本身的性质，可以实现自己的抽象类
						<div class="html">
							<pre>//定义extend方法
Object.extend = function(destination, source) { 
  for (property in source) { 
    destination[property] = source[property]; 
  } 
  return destination; 
}
Object.prototype.extend = function(object) { 
  return Object.extend.apply(this, [this, object]); 
}
//定义一个抽象基类base，无构造函数
function base(){}
base.prototype={
      initialize:function(){
               this.oninit(); //调用了一个虚方法
      }
}
//定义class1
function class1(){
      //构造函数
}
//让class1继承于base并实现其中的oninit方法
class1.prototype=(new base()).extend({
      oninit:function(){ //实现抽象基类中的oninit虚方法
             //oninit函数的实现
      }
});</pre>
这样，当在class1的实例中调用继承得到的initialize方法时，就会自动执行派生类中的oninit()方法。从这里也可以看到解释型语言执 行的特点，它们只有在运行到某一个方法调用时，才会检查该方法是否存在，而不会向编译型语言一样在编译阶段就检查方法存在与否。JavaScript中则 避免了这个问题。当然，如果希望在基类中添加虚方法的一个定义，也是可以的，只要在派生类中覆盖此方法即可。
<pre>例如：
//定义一个抽象基类base，无构造函数
function base(){}
base.prototype={
     initialize:function(){
          this.oninit(); //调用了一个虚方法
     },
     oninit:function(){} //虚方法是一个空方法，由派生类实现
}	
</pre>	
</div>
使用抽象类的示例:
<div class="html">
	<pre>以prototype-1.3.1为例，其中定义了一个类的创建模型：
//Class是一个全局对象，有一个方法create，用于返回一个类
var Class = { 
   create: function() { 
     return function() { 
       this.initialize.apply(this, arguments); 
     }
   }
}
这里Class是一个全局对象，具有一个方法create，用于返回一个函数（类），从而声明一个类，可以用如下语法：
var class1=Class.create();
这样和函数的定义方式区分开来，使JavaScript语言能够更具备面向对象语言的特点。现在来看这个返回的函数（类）：
function(){
      this.initialize.apply(this, arguments);
}
这个函数也是一个类的构造函数，当new这个类时便会得到执行。它调用了一个initialize方法，从名字来看，是类的构造函数。而从类的角度来看， 它是一个虚方法，是未定义的。但这个虚方法的实现并不是在派生类中实现的，而是创建完一个类后，在prototype中定义的，例如prototype可 以这样写：
var class1=Class.create();
class1.prototype={
      initialize:function(userName){
                      alert(“hello,”+userName);
      }
}
这样，每次创建类的实例时，initialize方法都会得到执行，从而实现了将类的构造函数和类成员一起定义的功能。其中，为了能够给构造函数传递参数，使用了这样的语句：
function(){
      this.initialize.apply(this, arguments);
}
实际上，这里的arguments是function()中所传进来的参数，也就是new class1(args)中传递进来的args，现在要把args传递给initialize，巧妙的使用了函数的apply方法，注意不能写成：
this.initialize(arguments);
这是将arguments数组作为一个参数传递给initialize方法，而apply方法则可以把arguments数组对象的元素作为一组参数传递过去，这是一种很巧妙的实现。
尽管这个例子在prototype-1.3.1中不是一个抽象类的概念，而是类的一种设计模式。但实际上可以把Class.create()返回的类看作 所有类的共同基类，它在构造函数中调用了一个虚方法initialize，所有继承于它的类都必须实现这个方法，完成构造函数的功能。它们得以实现的本质 就是对prototype的操作。</pre>
</div>
					</li>
					<li>js中不支持类继承机制，但我们可以通过将父类prototype中的成员方法复制到子类的prototype中来实现
						<div class="html">
							<pre>//ES6的类继承
(function(global){
  "use strict"

  //类的定义
  class Animal {
    //ES6中新型构造器
      constructor(name) {
          this.name = name;
      }
      //实例方法
      sayName() {
          console.log("My name is "+this.name);
      }
  }

  //类的继承
  class Programmer extends Animal {
      constructor(name) {
        //直接调用父类构造器进行初始化
          super(name);
      }
      sayName(){
          super.sayName();
      }
      program() {
          console.log("I\"m coding...");
      }
  }
  //测试我们的类
  var animal = new Animal("dummy"),
      akira = new Programmer("akira");
  animal.sayName();//输出 ‘My name is dummy’
  akira.sayName();//输出 ‘My name is akira’
  akira.program();//输出 ‘I"m coding...’

})(this);</pre>
						</div>
						<ul>
							<li><b>原型链方式</b></li>
							<li><b>对象冒充方式</b></li>
							<li><b>混合方式</b></li>
						</ul>
					</li>
				</ol>
			</li>
		</ol>
	</div>
</div>

<div class="mswitch">
	<div expander class="mb10">
		<b ng-click="toggleanswer()">关于DOM级别的一些问题
			<span ng-show="!answershow"><i class="f-arrow_down"></i></span>
			<span ng-show="answershow"><i class="f-arrow_up"></i></span>
		</b>
		<ol class="decimal" ng-show="answershow">
			<li>DOM0：不是W3C规范。
				<ul>
					<li>在标签内写onclick事件</li>
					<li>在JS写onclick=function(){}函数</li>
				</ul>
			</li>
			<li>DOM1：开始是W3C规范。专注于HTML文档和XML文档。</li>
			<li>DOM2：对DOM1增加了样式表对象模型
				<ul>
					<li>只有一个：监听方法，有两个方法用来添加和移除事件处理程序：addEventListener()和removeEventListener()。</li>
					<li>都有三个参数：
						<ul>
							<li>第一个参数是事件名（如click）；</li>
							<li>第二个参数是事件处理程序函数；</li>
							<li>第三个参数如果是true则表示在捕获阶段调用，为false表示在冒泡阶段调用。</li>
						</ul>
					</li>
					<li>只有2级DOM包含3个事件：
						<ul>
							<li>事件捕获阶段</li>
							<li>处于目标阶段</li>
							<li>事件冒泡阶段</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>DOM3：对DOM2增加了内容模型 (DTD 、Schemas) 和文档验证。</li>
		</ol>
	</div>
	<div expander class="mb10">
		<b ng-click="toggleanswer()">浏览器默认行为和事件冒泡处理
			<span ng-show="!answershow"><i class="f-arrow_down"></i></span>
			<span ng-show="answershow"><i class="f-arrow_up"></i></span>
		</b>
		<ol class="decimal" ng-show="answershow">
			<li><b>禁止默认行为：</b>
				<ul>
					<li>非IE下：在具体事件执行的程序里面写代码：event.preventDefault();</li>
					<li>IE下：在具体事件执行的程序里面写代码：event.returnValue=false;</li>
				</ul>
			</li>
			<li><b>阻止事件传播：</b>
				<ul>
					<li>非IE下：在具体事件执行的程序里面写代码：event.stopPropagation();</li>
					<li>IE下：在具体事件执行的程序里面写代码：event.cancelBubble=true;</li>
				</ul>
			</li>
		</ol>
	</div>
	<div expander class="mb10">
		<b ng-click="toggleanswer()">事件机制
			<span ng-show="!answershow"><i class="f-arrow_down"></i></span>
			<span ng-show="answershow"><i class="f-arrow_up"></i></span>
		</b>
		<ol class="decimal" ng-show="answershow">
			<li>
				<div expander class="mb10">
					<b ng-click="toggleanswer()">事件绑定：
						<span ng-show="!answershow"><i class="f-arrow_down"></i></span>
						<span ng-show="answershow"><i class="f-arrow_up"></i></span>
					</b>
					<div ng-show="answershow">
						<p class="mt10">常用的绑定事件的方法：</p>
						<ul>
							<li>在DOM元素中直接绑定
								<p class="mt10">DOM事件：onclick、onmouseover、onmouseout、onmousedown、onmouseup、ondblclick、onkeydown、onkeypress、onkeyup等等。</p>
								<div class="html">
					<pre>
//onclick事件：
&lt;input type="button" value="click me" onclick="hello()">
&lt;script>
function hello(){
alert("hello world!");
}
&lt;/script></pre>
								</div>
							</li>
							<li>在JavaScript代码中绑定
								<p class="mt10">在JavaScript代码中通过HTML标签的id、class绑定事件，使JavaScript代码与HTML标签分离，文档结构清晰，便于管理和开发。</p>
								<div class="html">
					<pre>
//onclick事件：
&lt;input type="button" value="click me" id="btn">
&lt;script>
document.getElementById("btn").onclick = function(){
alert("hello world!");
}
&lt;/script>
					</pre>
								</div>
							</li>
							<li>绑定事件监听函数
								<p class="mt10">用 addEventListener() 或 attachEvent() 来绑定事件监听函数，如果浏览器不支持 addEventListener() 方法, 可以使用 attachEvent() 方法替代。
								<div class="html">
		<pre>if (document.addEventListener) {                //所有主流浏览器，除了 IE 8 及更早 IE版本
document.addEventListener("click", myFunction,false);  //为false时表示在事件冒泡阶段调用事件处理程序
} else if (document.attachEvent) {             // IE 8 及更早 IE 版本，只支持事件冒泡
document.attachEvent("onclick", myFunction);
}

封装：
//使用变量，类似JSON类型的js对象方式进行事件处理程序的相关逻辑封装，主要解决了浏览器兼容性问题
//单独写进js中，便于html多次进行调用
var eventUtil = {
//添加事件
addEventHandle:function(element,eventType,fn){
if(element.addEventListener){
element.addEventListener(eventType,fn,false);//非IE
}else if(element.attachEvent){
element.attachEvent('on'+eventType,fn);//IE，这里拼接上'on',调用的时候不要加on，使用click等。
}else{
//不支持DOM2级，使用DOM0级方式
element['on'+eventType] = fn;//这里使用[]方式实现对象的属性添加，相当于.的作用，例如element.onClick=fn;所有浏览器都支持。
}
},
//删除事件
removeEventHandle:function(element,eventType,fn){
if(element.removeEventListener){//非IE,不带'on'
element.removeEventListener(eventType,fn,false);//这里传入fn，是因为DOM2级或DOM0级都可以一次给一个元素的同一个事件绑定多个程序，所以需要传入具体的程序fn进行删除
}else if(element.detachEvent){
element.detachEvent('on'+eventType,fn);//IE,带'on'
}else{
element['on'+eventType] = fn;//不支持DOM2级，使用DOM0级方式
}
},
//获取事件对象
getEvent:function(event){
return event?event:window.event;
},
//获取事件类型
getType:function(event){
return event.type;
},
//获取执行事件的目标元素
getTarget:function(event){
return event.target||event.srcElement;
},
//禁用默认行为
preventDefault:function(event){
if(event.preventDefault){
event.preventDefault();//非IE
}else{
event.returnValue = false;//针对IE
}
},
//阻止传播冒泡
stopPropagation:function(event){
if(event.stopPrapagation){
event.stopPropagation();//非IE
}else{
event.cancelBubble = true;//针对IE
}
}
}</pre>
								</div>
								<div class="html">
					<pre>调用：
var div = document.getElementsByTagName('div')[0];
var a = document.getElementsByTagName('a')[0];
eventUtil.addEventHandle(div,'click',function(e){
e = eventUtil.getEvent(e);
alert("给div增加的事件");
alert("事件执行的对象是："+eventUtil.getTarget(e).nodeName);
alert("事件类型是："+eventUtil.getType(e));
});
eventUtil.addEventHandle(a,'click',function(e){
e = eventUtil.getEvent(e);
alert("给a增加的事件");
alert("事件执行的对象是："+eventUtil.getTarget(e).nodeName);
alert("事件类型是："+eventUtil.getType(e));
//上面两步执行以后,点击a标签，发现a的和div的都会执行，同时会跳转到页面，
//说明事件冒泡和默认行为（a的href决定了a的默认行为是跳转）都存在
eventUtil.preventDefault(e);//禁止默认行为
eventUtil.stopPropagation(e);//停止传播冒泡
});</pre>
								</div>
							</li>
						</ul>
					</div>
				</div>
			</li>
			<li>
				<div expander class="mb10">
					<b ng-click="toggleanswer()">事件监听
						<span ng-show="!answershow"><i class="f-arrow_down"></i></span>
						<span ng-show="answershow"><i class="f-arrow_up"></i></span>
					</b>
					<div ng-show="answershow">
						<p>关于事件监听，W3C规范中定义了3个事件阶段，依次是捕获阶段、目标阶段、冒泡阶段。</p>
						<div class="mt10">事件监听方法：
							<ul>
								<li>element.addEventListener(type, fn[, useCapture]); // IE6~8不支持，支持事件冒泡和捕获</li>
								<li>element.attachEvent('on' + type, fn); // IE6~10，IE11不支持，只支持事件冒泡</li>
								<li>element['on' + type] = fn // 所有浏览器，只支持事件冒泡，不支持对同一个元素的同一个事件注册多个事件监听器</li>
							</ul>
						</div>
						<p class="mt10">优点：</p>
						<ul>
							<li>可以绑定多个事件
								<div class="html">
									<pre>&lt;input type="button" value="click me" id="btn3">
		
&lt;script>
var btn3 = document.getElementById("btn3");

//常规的事件绑定只执行最后绑定的事件
btn3.onclick = function(){
alert("hello 1"); //不执行
}
btn3.onclick = function(){
alert("hello 2"); //执行
}
//事件监听两个事件都执行了
btn3.addEventListener("click",hello1);
btn3.addEventListener("click",hello2);

function hello1(){
alert("hello 1");
}
function hello2(){
alert("hello 2");
}
&lt;/script>
									</pre>
								</div>
							</li>
							<li>可以解除相应的绑定
								<div class="html">
									<pre>&lt;input type="button" value="click me" id="btn5">
		
&lt;script>
var btn5 = document.getElementById("btn5");
btn5.addEventListener("click",hello1);//执行了
btn5.addEventListener("click",hello2);//不执行
btn5.removeEventListener("click",hello2);

function hello1(){
alert("hello 1");
}
function hello2(){
alert("hello 2");
}
&lt;/script></pre>
								</div>
							</li>
						</ul>
					</div>
				</div>
			</li>
			<li>
				<div expander class="mb10">
					<b ng-click="toggleanswer()">事件委托
						<span ng-show="!answershow"><i class="f-arrow_down"></i></span>
						<span ng-show="answershow"><i class="f-arrow_up"></i></span>
					</b>
					<div ng-show="answershow">
						<ul>
							<li>事件委托就是利用冒泡的原理，把事件加到父元素或祖先元素上，触发执行效果。</li>
							<li>优点：
								<ul>
									<li>提高JavaScript性能。事件委托可以显著的提高事件的处理速度，减少内存的占用。
										<div class="html">
									<pre>&lt;ul id="list">
&lt;li id="item1" >item1&lt;/li>
&lt;li id="item2" >item2&lt;/li>
&lt;/ul>

&lt;script>
var item1 = document.getElementById("item1");
var item2 = document.getElementById("item2");

//传统写法
item1.onclick = function(){
alert("hello item1");
}
item2.onclick = function(){
alert("hello item2");
}
//事件委托
document.addEventListener("click",function(event){
var target = eventUtil.getTarget(event);
if(target == item1){
	alert("hello item1");
}else if(target == item2){
	alert("hello item2");
}
})
&lt;/script></pre>
										</div>
									</li>
									<li>动态的添加DOM元素，不需要因为元素的改动而修改事件绑定。
										<div class="html">
									<pre>&lt;ul id="list">
&lt;li id="item1" >item1&lt;/li>
&lt;li id="item2" >item2&lt;/li>
&lt;/ul>

&lt;script>
var list = document.getElementById("list");

//传统写法
var item = list.getElementsByTagName("li");
for(var i=0 ; i &lt; item.length ; i++){
(function(i){
    item[i].onclick = function(){
	    alert(item[i].innerHTML);
    }
})(i)
}
var node=document.createElement("li");
var textnode=document.createTextNode("item3");
node.appendChild(textnode);
list.appendChild(node);
//点击item1到item2都有事件响应，但是点击item3时，没有事件响应。说明传统的事件绑定无法对动态添加的元素而动态的添加事件。

//事件委托
document.addEventListener("click",function(event){
var target = eventUtil.getTarget(event);
if(target.nodeName == "LI"){
    alert(target.innerHTML);
}
})
var node=document.createElement("li");
var textnode=document.createTextNode("item3");
node.appendChild(textnode);
list.appendChild(node);
//当点击item3时，item3有事件响应。说明事件委托可以为新添加的DOM元素动态的添加事件。
&lt;/script></pre>
										</div>
									
									</li>
								</ul>
							</li>
							<li>on和addEventListener的区别：
								<ul>
									<li>jquery中用on来绑定事件，写法有：
										<ul>
											<li>$(document).on('click','.classname',function(){});</li>
											<li>$('.classname').on('click',function(){});</li>
										</ul>
										$(document).on是把事件委托到了document上 ;$('.classname').on是把事件直接绑定到类是classname的元素。
									</li>
									<li>addEventListener是js原生方法来绑定事件</li>
								</ul>
							</li>
						</ul>
					</div>
				</div>
			</li>
		</ol>
	</div>
	<div expander class="mb10">
		<b ng-click="toggleanswer()">事件对象
			<span ng-show="!answershow"><i class="f-arrow_down"></i></span>
			<span ng-show="answershow"><i class="f-arrow_up"></i></span>
		</b>
		<ol class="decimal" ng-show="answershow">
			<li>event：所有浏览器都支持</li>
			<li>window.event：只有Firefox不支持</li>
		</ol>
	</div>
	<div expander class="mb10">
		<b ng-click="toggleanswer()">事件分类
			<span ng-show="!answershow"><i class="f-arrow_down"></i></span>
			<span ng-show="answershow"><i class="f-arrow_up"></i></span>
		</b>
		<ol class="decimal" ng-show="answershow">
			<li>鼠标事件
				<ul>
					<li>鼠标左键操作
						<ul>
							<li>onclick(鼠标点击的时候)</li>
							<li>ondblclick(鼠标双击的时候)</li>
							<li>onmousedown(鼠标按下的时候)</li>
							<li>onmouseout(鼠标从某元素中移开的时候，冒泡)</li>
							<li>onmouseleave(不冒泡)</li>
							<li>onmouseover(鼠标移入某元素，冒泡)</li>
							<li>onmouseenter(不冒泡)</li>
							<li>onmouseup(鼠标松开)</li>
							<li>onmousemove(鼠标移动的时候)</li>
							<li>onmousewheel(滚轮事件)
								<ul>
									<li>Firefox使用DOMMouseScroll，其他的浏览器使用mousewheel。</li>
									<li>滚动事件触发时Firefox使用detail属性捕捉滚轮信息，其他的浏览器使用wheelDelta。</li>
								</ul>
								<div class="html">
									<pre>//兼容写法：
/*Firefox使用addEventListener方法绑定DomMouseScroll事件*/
if(document.addEventListener){
   document.addEventListener('DOMMouseScroll',scrollFunc,false);
}
/*IE Opera Chrome 其他的浏览器使用onmousewheel*/
window.onmousewheel=document.onmousewheel=scrollFunc;
									</pre>
								</div>
							</li>
						</ul>
					</li>
					<li>鼠标右键操作
						<ul>
							<li>oncontextmenu</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>键盘事件
				<ul>
					<li>onkeydown(键盘的某个按键按下)</li>
					<li>onkeypress(键盘的某个按键按下并按住不放)</li>
					<li>onkeyup(键盘的某个按键被松开)</li>
				</ul>
			</li>
			<li>HTML事件
				<ul>
					<li>表单事件：
						<ul>
							<li>onsubmit(点击提交按钮时触发)</li>
							<li>onreset(重置按钮被点击时触发)</li>
							<li>onblur(元素失去焦点时触发，不冒泡)</li>
							<li>onfocus(元素获得焦点时触发，不冒泡)</li>
							<li>onchange(用户改变文本框或者文本域的内容时触发，需要失去焦点才触发)</li>
							<li>oninput(value属性值发生改变时触发，内容修改后立即被触发，通过js改变的value不会触发此事件，ie8及以下不支持)</li>
							<li>onPropertyChange(IE专属，只有IE11以下浏览器支持，实时触发，即每增加或删除一个字符就会触发，通过js改变也会触发该事件)
								<div class="html">
									<pre>//兼容写法：
if('oninput' in document.createElement('input')){//ie8及以下为false
	object.onInput = fn;
}else{
	object.onPropertyChange = fn;
}
									</pre>
								</div>
							</li>
						</ul>
					</li>
					<li>Window事件：
						<ul>
							<li>onload(页面加载后触发，不冒泡)</li>
							<li>onunload(用户退出页面时触发，不冒泡)</li>
							<li>onresize(窗口或者框架的尺寸被调整时触发)</li>
							<li>onscroll(滚动条滚动触发)
								<ul>
									<li>在获取滚动条距离的时候，Safari不识别document.documentElement.scrollTop，必须要加上document.body.scrollTop</li>
									<li>即var scrolltop=document.documentElement.scrollTop||document.body.scrollTop;这样才能兼容各个浏览器！</li>
								</ul>
							</li>
						</ul>
					</li>
					<li>编辑事件：
						<ul>
							<li>选择(通过return false来进行屏蔽)
								<ul>
									<li>onselect(文本被选定时触发，即文本已经被选中)</li>
									<li>onselectstart(目标对象被开始选中时，即选中动作刚开始，尚未实质性被选中)</li>
								</ul>
								<ul class="c-red">
									<li>onselectstart事件不被input和textarea标签支持，而onselect事件只被input和textarea支持</li>
									<li>Firefox/Opera不支持onselectstart事件</li>
									<li>Firefox中可以使用CSS "-moz-user-select:none"属性来禁止文本选定</li>
									<li>webkit浏览器可以使用CSS "-webkit-user-select:none"属性来禁止文本选定</li>
									<li>其他浏览器使用CSS "user-select:none"属性来禁止文本选定(IE6-9不支持，但支持使用标签属性 onselectstart="return false;" 来达到 user-select:none 的效果)</li>
									<li>Opera支持使用私有的标签属性 unselectable="on" 来达到 user-select:none 的效果</li>
								</ul>
								<div class="html">
									<pre>//兼容写法：
&lt;style>
.user-select-none{-webkit-user-select:none;-moz-user-select:none;-o-user-select:none;user-select:none;}
&lt;/style>
&lt;div class="user-select-none" onselectstart="return false;" unselectable="on">&lt;/div>
									</pre>
								</div>
							</li>
							<li>复制(通过return false禁止复制)
								<ul>
									<li>onbeforecopy(将网页内容复制到剪贴版时触发)</li>
									<li>oncopy(在网页中复制内容时触发)</li>
								</ul>
							</li>
							<li>剪切
								<ul>
									<li>onbeforecut(当选中区从文档中删除之前触发)</li>
									<li>oncut(当对象或选中区从文档中删除并添加到系统剪贴板上时触发)</li>
								</ul>
							</li>
							<li>粘贴
								<ul>
									<li>onbeforepaste(在选中区从系统剪贴板粘贴到文档前触发)</li>
									<li>onpaste(当用户粘贴数据以便从系统剪贴板向文档传送数据时触发)</li>
								</ul>
							</li>
						</ul>
					</li>
					<li>其他
						<ul>
							<li>onabort(图形加载中断时触发)</li>
							<li>onerror(加载文档或者图像时发生错误触发)</li>
						</ul>
					</li>
				</ul>
			</li>
		</ol>
	</div>
	<div expander class="mb10">
		<b ng-click="toggleanswer()">touch和mouse
			<span ng-show="!answershow"><i class="f-arrow_down"></i></span>
			<span ng-show="answershow"><i class="f-arrow_up"></i></span>
		</b>
		<div ng-show="answershow">
			<ol class="decimal">
				<li>pc端：鼠标会产生onmousedown、onmouseup、onmouseout、onmouseover、onmousemove的事件。</li>
				<li>touch：触摸事件
					<ul>
						<li>ontouchstart：手指触摸到屏幕触发</li>
						<li>ontouchmove：当手指在屏幕上移动时触发</li>
						<li>ontouchend：当手指离开屏幕时触发</li>
						<li>ontouchcancel：当一些更高级别的事件发生的时候（如电话接入或者弹出信息）会取消当前的touch操作，即触发。</li>
						<li>在触屏操作后，手指提起的一刹那（即发生ontouchend后），系统会判断接收到事件的element的内容是否被改变，如果内容被改变，接下来的事件都不会触发，如果没有改变，会按照mousedown，mouseup，click的顺序触发事件。特别需要提到的是，只有再触发一个触屏事件时，才会 触发上一个事件的mouseout事件。</li>
					</ul>
				</li>
			</ol>
			<div class="html">
				<pre>/*注册滑动事件(pc鼠标滚动，移动手指滑动)*/
if(document.addEventListener){
	document.addEventListener('DOMMouseScroll',scrollFunc,false);
	document.addEventListener('touchmove',scrollFunc, false);
}
window.onmousewheel=document.onmousewheel=scrollFunc;

/*注销滑动事件*/
if(document.removeEventListener){
	document.removeEventListener('DOMMouseScroll',scrollFunc,false);
	document.removeEventListener('touchmove',scrollFunc, false);
}
window.onmousewheel=document.onmousewheel=null;

var scrollFunc=function(){
	//code here...
};</pre>
		</div>
			<div class="example-demo">
				<div class="html">
				<pre>function touchStart(event) {
	try {
		var touch = event.touches[0];
		var x = Number(touch.pageX);
		var y = Number(touch.pageY);
		startX = x;
		startY = y;
	} catch (e) {}
}
function touchEnd(event) {
	try {
		for (var i = 0; i < event.changedTouches.length; i++) {
			var ot = event.changedTouches[i];
			if (!ot) return;
			_cur = parseInt(Math.abs(slider.position().left/_W));
			var dx = startX - ot.clientX;
			if(dx>0){
				console.log('左滑动');
			}
			else{
				console.log('右滑动');
			}
		}
	} catch (e) {}
}
var touch=('ontouchstart' in window) || window.DocumentTouch && document instanceof DocumentTouch;
if(touch){
	document.addEventListener('touchstart',touchStart,false);
	document.addEventListener('touchend',touchEnd,false);
}

//pc未测试
$('.elem').on({
	mousedown:function(e){
		var evt = e.originalEvent;
		try {
			startX = evt.pageX;
			startY = evt.pageY;
		} catch (e) {}
	},
	mouseup:function(e){
		var evt = e.originalEvent;
		if(e.button===0){
			try {
				var dx = startX - evt.pageX,
				dy = startY - evt.pageY;
				if ((Math.abs(dx) === 0 && Math.abs(dy) === 0)) {
					$('#trans-record .popup').modal('show');
				}
			} catch (e) {}
		}
	}
})</pre>
				</div>
			</div>
		</div>
	</div>
	<div expander class="mb10">
		<b ng-click="toggleanswer()">click和tap
			<span ng-show="!answershow"><i class="f-arrow_down"></i></span>
			<span ng-show="answershow"><i class="f-arrow_up"></i></span>
		</b>
		<div ng-show="answershow">
			<ol>
				<li>在手机web端，click会有200-300ms的延迟，所以一般用tap代替click作为点击事件。</li>
				<li>tap：触碰事件
					<ul>
						<li>tap：手指碰一下屏幕会触发</li>
						<li>longTap：手指长按屏幕会触发</li>
						<li>singleTap：单次点击</li>
						<li>doubleTap：双次点击</li>
					</ul>
				</li>
			</ol>
		</div>
	</div>
	<div expander class="mb10">
		<b ng-click="toggleanswer()">swipe和touch
			<span ng-show="!answershow"><i class="f-arrow_down"></i></span>
			<span ng-show="answershow"><i class="f-arrow_up"></i></span>
		</b>
		<div ng-show="answershow">
			<ol>
				<li>swipe：滑动事件
					<ul>
						<li>swipe：手指在屏幕上滑动时会触发</li>
						<li>swipeLeft：手指在屏幕上向左滑动时会触发</li>
						<li>swipeRight：手指在屏幕上向右滑动时会触发</li>
						<li>swipeUp：手指在屏幕上向上滑动时会触发</li>
						<li>swipeDown：手指在屏幕上向下滑动时会触发</li>
					</ul>
				</li>
			</ol>
		</div>
	</div>
	<div expander class="mb10">
		<b ng-click="toggleanswer()">touch事件中的touches、targetTouches和changedTouches详解
			<span ng-show="!answershow"><i class="f-arrow_down"></i></span>
			<span ng-show="answershow"><i class="f-arrow_up"></i></span>
		</b>
		<ol class="decimal" ng-show="answershow">
			<li>touches：当前屏幕上所有触摸点的列表
			</li>
			<li>targetTouches：当前对象上所有触摸点的列表
			</li>
			<li>changedTouches：涉及当前（引发）事件的触摸点的列表
			</li>
			<li><b>区别：</b>
				<ul>
					<li>手指离开屏幕后，touches和targetTouches中将不会再有值，changedTouches还会有一个值，此值为最后一个离开屏幕的手指的接触点</li>
				</ul>
			</li>
			<li><b>坐标获取：</b>
				<ul>
					<li>touchstart和touchmove使用：e.targetTouches[0].pageX或（jquery）e.originalEvent.targetTouches[0].pageX</li>
					<li>touchend使用：e.targetTouches[0].pageX或（jquery）e.originalEvent.changedTouches[0].pageX</li>
				</ul>
				<div class="html">
					<pre>var touch=('ontouchstart' in window) || window.DocumentTouch && document instanceof DocumentTouch;

if(touch){
	//js
	document.addEventListener('touchstart',touchStart,false);
	//jquery
	$('body').on('touchstart',touchStart);
}</pre>
				</div>
			</li>
		</ol>
	</div>
</div>
<div class="mswitch">
	<h3 class="mb10">JavaScript继承</h3>
	<div class="example-demo">
	</div>
	<div class="example-desc">
		<ol>
			<li>
				<h5>基于对象的继承</h5>
				<div class="html">
					<p>基于对象的继承也叫原型继承。我们知道通过JavaScript字面量创建的对象都会连接到Object.prototype，因此我们用Object.prototype来实现继承。本质上是摒弃类，不调用构造函数，而是用Object.create()，直接让新对象继承旧对象的属性。例如：</p>
					<pre>var person = {
    name: "Jack",
    getName: function () { return this.name; }
}
var p1 = Object.create(person);
console.log(p1.getName());    //Jack</pre>
<p>代码很简单，person有一个属性和一个方法。对象p1通过Object.create()来继承，第一个参数prototype指向person的prototype，这样对象p1就继承了person的属性和方法。</p>
<p>Object.create()还可以指定第二个参数，即数据属性，将其添加到新对象中。数据属性可设4个描述符value， writable，enumerable，configurable 。后3个看名字也能猜出意思，不指定的话默认为false。因为和本篇关系不大，就不跑题了，只看看设置value的情况：</p>
<pre>var p2 = Object.create(person, {
    name: {
        value: "Zhang"
    }
});
console.log(p2.getName());    //Zhang</pre>
<p>用Object.create()相当于创建了一个全新的对象，你可以给该对象任意新增，重载它的属性和方法：</p>
<pre>var person = {
    name: "Jack",
    getName: function () { return this.name; },
    getAge: function() { return this.age; } //注意并没有age这个成员变量，依赖子类实现
}

var p3 = Object.create(person);
p3.name = 'Rose';
p3.age = 17;
p3.location = '上海';
p3.getLocation = function() { return this.location; }

console.log(p3.getName());    //Rose
console.log(p3.getAge());     //17
console.log(p3.getLocation());    //上海</pre>
<p>在person中并没有age这个属性，因此你调用person.getAge();将得到undefined。但在对象p3里新定义了age这个属性，于是就能正确地调用基类的getAge方法。另外子类重载了name的值，且新定义了location属性和getLocation方法。</p>
				</div>
			</li>
			<li>
				<h5>基于类型的继承</h5>
				<div class="html">
					<p>基于类型的继承是通过构造函数依赖于原型的继承，而非依赖于对象。例如：</p>
					<pre>function Person(name) {
    this.name = name;
    this.getName = function () { return this.name; };  
}
function Student(name, age) {
    Person.call(this, name);
    this.age = age;
    this.getAge = function () { return this.age; }; 
}
Student.prototype = new Person();    //需要通过new来访问基类的构造函数

var p = new Person('Cathy');
var s = new Student('Bill', 23);

console.log(p.getName());    //Cathy
console.log(s.getName());    //Bill
console.log(s.getAge());     //23</pre>
<p>Student继承自Person。name虽然是在基类Person里被定义的，但用new调用Person的构造函数后，this将被绑定到子类Student对象上，因此name最终是定义在子类Student对象上的。</p>
				<h5 class="mt20"><b>保护隐私</b></h5>
				<p>之所以定义getName，getAge等方法就是不想让用户直接访问name，age等属性。可惜上面两种继承均无法保护隐私，均可像p.name，p.age这样直接访问属性。如果认为这些属性的隐私非常重要，希望模拟出OO语言中private属性的效果，可以用函数模块化。</p>
				<p>所谓函数模块化，本质上就是在函数内新建一个对象，新对象的方法里使用参数对象的属性，然后将新对象返回。此时新对象里是没有参数对象的属性的，达到了保护隐私的目的。代码如下：</p>
				<pre>var person = function(spec) {
    var that = {};        //新对象
    that.getName = function () { return spec.name; };  //使用参数的属性
    that.getAge = function() { return spec.age; };  //使用参数的属性
    return that;        //返回新对象
}

var p4 = person({name: 'Jane', age: 20});

console.log(p4.name);    //undefined
console.log(p4.age);     //undefined
console.log(p4.getName());    //Jane
console.log(p4.getAge());     //20</pre>
<p>因为函数person返回的是新对象that，而that里并没有name和age属性，因此直接访问会得到undefined。只能通过that暴露出的两个接口来获取name和age。</p>
<p>进一步实现多层继承也非常方便，效果如下，不赘述：</p>
<pre>var student = function(spec) {
    var that = person(spec);        //新对象继承自person
    that.getRole = function() { return 'student'; };  //新对象增加方法
    that.getInfo = function() {
        return spec.name + ' ' + spec.age + ' ' + that.getRole();
    };
    return that;    //返回新对象
};

var p5 = student({name:'Andy', age:12});

console.log(p5.name);       //undefined
console.log(p5.getName());  //Andy
console.log(p5.getRole());  //student
console.log(p5.getInfo());  //Andy 12 student</pre>
				</div>

			</li>
		</ol>
	</div>
</div>

<div class="mswitch">
	<h3 class="mb10">JS赋值运算</h3>
	<div class="example-demo">
	</div>
	<div class="example-desc">
		<ol>
			<li>
				<h3>引用类型的赋值运算：</h3>
				<div class="html">
					<pre>var foo = { n: 1 };
		var bar = foo;
		foo.x = foo = { n: 2 };
		console.log(foo.x); // undefined</pre>
				</div>
				<h5>解释上面的现象：</h5>
				<ul>
					<li>
						<p>首先是两个变量的声明和初始化，var foo = { n: 1 }; var bar = foo;，这个很好理解，就是foo和bar同时指向了一个相同的对象{ n: 1 }。</p>
					</li>
					<li>
						<p>对于表达式foo.x = foo = { n: 2 };，我们都知道它实际上等于是foo.x = (foo = { n: 2 })。<span class="red">* 赋值运算符具有右结合性</span></p>
					</li>
					<li>
						<p>虽然赋值运算符具有右结合性，然而它首先做的是得到表达式foo.x的值，它返回一个指向对象{ n: 1}的x成员的引用，需要注意的是，这个时候foo并没有改变引用的指向。</p>
					</li>
					<li>
						<p>计算右边的结果，就是让foo指向另外的一个对象{n: 2}，返回值就是其右边运算式的结果，即对象{n: 2}</p>
					</li>
					<li>
						<p>那么现在应该清楚了，赋值语句中foo.x的结果是指向对象一成员x的引用。<span class="red">{n: 2}只有成员n,没有x</span>，而下面的console.log(foo.x)中的foo指向的是对象二，所以这里foo.x返回undefined就理所当然了。</p>
					</li>
				</ul>
				<h5>试着输出对象一，即bar（因为它从始至终指向的是对象一）：</h5>
				<div class="html">
					<pre>var foo = { n: 1 };
		var bar = foo;
		foo.x = foo = { n: 2 };
		console.log(bar); // { n: 1, x: { n: 2 } }</pre>
				</div>

				<h5>工作步骤图解：</h5>
				<div class="html">
					<pre>
		var a = {n:1};
		var b = a;
		a.x = a = {n:2};
		console.log(a.x);// --> undefined
		console.log(b.x);// --> [object Object]
		</pre>
				</div>
				<ul>
					<li>首先是<b>var a = {n:1}; var b = a;</b>
						<p>在这里a指向了一个对象{n:1}（我们姑且称它为对象A），b指向了a所指向的对象，也就是说，在这时候a和b都是指向对象A的。</p>
					</li>
					<li><b>a.x = a = {n:2};</b>
						<p>我们知道js的赋值运算顺序永远都是从右往左的，不过由于“.”是优先级最高的运算符，所以这行代码先“计算”了a.x。</p>
						<p>这时候发生了这个事情——a指向的对象{n:1}新增了属性x（虽然这个x是undefined的）：</p>
						<img src="assets/img/js-fz01.png"/>
						<p>从图上可以看到，由于b跟a一样是指向对象A的，要表示A的x属性除了用a.x，自然也可以使用b.x来表示了。</p>
					</li>
					<li>
						<p>接着，依循“从右往左”的赋值运算顺序先执行 a={n:2} ，这时候，a指向的对象发生了改变，变成了新对象{n:2}（我们称为对象B）：</p>
						<img src="assets/img/js-fz02.png"/>
						<p>接着继续执行 a.x=a，很多人会认为这里是“对象B也新增了一个属性x，并指向对象B自己”</p>
						<p>但实际上并非如此，<span class="red">由于（ .  运算符最先计算）一开始js已经先计算了a.x，便已经解析了这个a.x是对象A的x，所以在同一条公式的情况下再回来给a.x赋值，也不会说重新解析这个a.x为对象B的x。</span></p>
						<p>所以 a.x=a 应理解为对象A的属性x指向了对象B:</p>
						<img src="assets/img/js-fz03.png"/>
						<p>那么这时候结果就显而易见了。当console.log(a.x)的时候，a是指向对象B的，但对象B没有属性x。</p>
						<p>而在console.log(b.x)的时候，由于b.x表示对象A的x属性，该属性是指向对象B，自然也输出了[object Object]了</p>
					</li>
				</ul>
			</li>
		</ol>
	</div>
</div>
<div class="mswitch">
	<ol class="decimal">
		<li>
			<h3 class="mb10">“浏览器模式”和“文档模式”</h3>
			<ul>
					<li>只有IE浏览器中才会有“浏览器模式”和“文档模式”，兼容性视图涉及两个重要的功能便是“浏览器模式【browser mode】”和“文档模式【document mode】”。</li>
					<li>如果浏览器模式与文档模式不一致的时候，我们一般认为还是以文档模式为准【渲染页面】</li>
					<li>js方法：
						<ul>
							<li>浏览器模式：navigator.userAgent</li>
							<li>文档模式：document.documentMode</li>
						</ul>
					</li>
					<li>区别：
						<ul>
							<li>浏览器模式：
								<ul>
									<li>影响的是浏览器的版本及IE的条件注释，主要表现在展现，对CSS影响很大。</li>
									<li>对服务器端获得浏览器版本号appVersion也会有影响</li>
									<li>用于切换IE针对该网页的默认文档模式、对不同版本浏览器的条件备注解析、发送给网站服务器的用户代理（User-Agent）字符串的值。</li>
									<li>网站可以根据浏览器返回的不同用户代理字符串判断浏览器的版本和安装的功能，这样就可以向不同的浏览器返回不同的页面内容。</li>
								</ul>
							</li>
							<li>文档模式：
								<ul>
									<li>影响的是IE的排版引擎，对DOM的渲染会产生影响。</li>
									<li>用于指定IE的页面排版引擎（Trident）以哪个版本的方式来解析并渲染网页代码。</li>
									<li>切换文档模式会导致网页被刷新，但不会更改用户代理字符串中的版本号，也不会从服务器重新下载网页。</li>
								</ul>
							</li>
						</ul>
					</li>
				</ul>
		</li>
		<li>
			<h3 class="mb10">IE8、IE7不能兼容的js方法</h3>
			<ul>
				<li><b>document.getElementsByClassName：</b>
					不兼容IE8及以下版本。
				</li>
				<li><b>document.querySelector：</b>
					兼容IE8，不兼容IE7及以下版本。
				</li>
				<li><b>document.addEventListener</b>
					不兼容IE8及以下版本，用document.attachEvent替代。（document.attachEvent支持IE6-IE10）
				</li>
			</ul>
		</li>
	</ol>
</div>
