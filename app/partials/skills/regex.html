<div class="mlist">
	<div class="mtit"><span>目录</span></div>
	<div class="mcon">
		<ol>
			<li><a href="">字符串操作</a></li>
			<li><a href="">正则表达式简介</a></li>
			<li><a href="">正则表达式常用方法</a></li>
			<li><a href="">正则表达式的字符</a></li>
			<li><a href="">常用的正则表达式</a></li>
			<li><a href="">捕获组</a></li>
			<li><a href="">反向引用</a></li>
			<li><a href="">.gitignore正则书写</a></li>
		</ol>
	</div>
</div>

<!--div.mswitch>(div.pt10.pb10+div.example-visualize)-->

<div class="mswitch">
	<ol class="decimal">
		<li><b>字符方法</b>
			<div class="html">
				<pre>var mystr="Hello World!";
console.log(mystr.charAt(7));    //o
console.log(mystr.charCodeAt(1)); //101 </pre>
			</div>
			<ul>
				<li>charAt：返回给定位置的字符
					<ul>
						<li>从0开始</li>
					</ul>
				</li>
				<li>charCodeAt：返回该位置字符的字符编码</li>
			</ul>
		</li>
		<li><b>字符串操作方法</b>
			<ul>
				<li>字符串拼接：contact()，但是实践中我们使用最多的还是加操作符+更便捷</li>
				<li>获取子字符串：
					<div class="html">
						<pre>var str="hello world";</pre>
					</div>
					<ul>
						<li>slice(start, stop)：
							<div class="html">
								<pre>console.log(str.slice(3));//lo world
console.log(str.slice(3,7));//lo w
console.log(str.slice(3,-4));//lo w -4+11=7表示子字符串最后一个字符后面的位置</pre>
							</div>
						</li>
						<li>substring(start, stop)：
							<div class="html">
				<pre>console.log(str.substring(3));    //lo world
console.log(str.substring(3,7));//lo w
console.log(str.substring(3,-4));  //hel</pre>
							</div>
						</li>
						<li>substr(start, length)：
							<div class="html">
				<pre>console.log(str.substr(3));//lo world
console.log(str.substr(3,7));//lo worl 7表示返回7个字符
console.log(str.substr(3,-4));//""空字符串 </pre>
							</div>
						</li>
					</ul>
					<ul>
						<li>第一个参数都是指定起始截取位置；如果为负数，那么该参数声明从字符串的尾部开始算起，-1指字符串中最后一个字符。</li>
						<li>未填第二参数时，自动截取起始位置到字符串末尾，即将字符串的长度作为结束位置；</li>
						<li>slice()和substring()的第二个参数指定的是子字符串最后一个字符<b class="c-red">后面的位置</b>，就是包含头不包含尾，substr()的第二个参数指定的则是返回的字符个数；</li>
						<li>substring参数只能是非负整数，会将负数转化为0，例如substring(3,-4)相当于substring(3,0)，<b class="c-red">此外由于这个方法会将较小数作为开始位置，较大数作为结束位置</b>，所以相当于调用str.substring(0,3); 。</li>
						<li>slice的第二个参数原则上也不该为负数，若强行传递负数，会被当成0处理，返回长度为 0 的字符串，即空串。</li>
					</ul>
				</li>
			</ul>
		</li>
		<li><b>字符串位置方法</b>
			<ul>
				<li>indexOf()：从前向后搜索</li>
				<li>lastIndexOf()：从后向前搜索</li>
			</ul>
			<ul>
				<li>都是返回子字符串的位置，如果没有找到，则返回-1</li>
				<li>都可以接收两个参数：要查找的子字符串和开始搜索的位置 </li>
			</ul>
		</li>
		<li><b>trim()方法</b>
			用来删除字符串前后的空格
		</li>
		<li><b>字符串大小写转换方法</b>
			<ul>
				<li>toLowerCase</li>
				<li>toLocaleLowerCase</li>
				<li>toUpperCase</li>
				<li>toLocaleUpperCase</li>
			</ul>
		</li>
		<li><b>字符串的模式匹配方法</b>
			<ul>
				<li>match()：
					<div class="html">
						<pre>var str="cat,bat,sat,fat";
var regexp = /.at/;

//与regexp.exec(str)相同
var matches = str.match(regexp);
console.log(matches)</pre>
					</div>
					<ul>
						<li>本质上与RegExp的exec()方法相同。</li>
						<li>只接受一个参数，由字符串或RegExp对象指定的一个正则表达式</li>
						<li>返回一个数组</li>
					</ul>
				</li>
				<li>search()：
					<div class="html">
						<pre>var str="cat,bat,sat,fat";
var pos=str.search(/cat/);
console.log(pos);//1 1表示at字符串在原来字符串中第一次出现的位置 </pre>
					</div>
					<ul>
						<li>只接受一个参数，由字符串或RegExp对象指定的一个正则表达式</li>
						<li>返回字符串中第一个匹配项的索引，如果没有匹配项，返回-1</li>
					</ul>
				</li>
			</ul>
		</li>
		<li>replace()：
			<div class="html">
						<pre>var str="cat,bat,sat,fat";
var res=str.replace("at","one");//第一个参数是字符串，所以只会替换第一个子字符串
console.log(res);//cone,bat,sat,fat

var res1=str.replace(/at/g,"one");//第一个参数是正则表达式，所以会替换所有的子字符串
console.log(res1);//cone,bone,sone,fone </pre>
			</div>
		</li>
		<li>split(separator,length)：
			<div class="html">
				<pre>var str="red,blue,green,yellow";
console.log(str.split(","));//["red", "blue", "green", "yellow"]
console.log(str.split(",",2));//["red", "blue"]  第二个参数用来限制数组大小
console.log(str.split(/[^\,]+/));// ["", ",", ",", ",", ""] //第一项和最后一项为空字符串是因为正则表达式指定的分隔符出现在了子字符串的开头，即"red"和"yellow"
    //[^...] 不在方括号内的任意字符  只要不是逗号都是分隔符 </pre>
			</div>
			<ul>
				<li>第一个参数：字符串或正则表达式，从该参数指定的地方分割。</li>
				<li>基于指定的字符，将字符串分割成字符串数组，返回一个新的数组，当指定的字符为空字符串时，将会分隔整个字符串。 </li>
				<li>第二个参数，表示返回的字符串数组的最大长度。</li>
			</ul>
		</li>
	</ol>
</div>
<div class="mswitch">
	<ol class="decimal">
		<li><b>组成：</b>
			<div class="html"><pre>new RegExp(pattern,modifiers);</pre></div>
			<ul>
				<li>模式：pattern
					<ul>
						<li>方括号[]：<b class="c-red">单个匹配</b>
							<p>用于定义匹配的字符范围，匹配任何<b class="c-red">一个</b>列在方括号中的字符</p>
							<p>[^abc]     查找任何不在方括号中的字符</p>
						</li>
						<li>圆括号()：<b class="c-red">多个匹配</b>
							<p>分组，用于提取匹配的字符串，表达式中有几个()就有几个相应的匹配字符串</p>
							<p>(red|blue|green)     查找任何指定的选项</p>
						</li>
						<li>大括号{}：<b class="c-red">匹配次数</b>
							<p>表示匹配的次数</p>
						</li>
						<li>元字符：<b class="c-red">( [ { \ ^ $ | ) ? * + .</b>
							<p>是拥有特殊含义的字符</p>
						</li>
						<li>量词：
							<ul>
								<li><span class="col-1"> * </span>： <span class="col-2 red">匹配前面的子表达式零次或多次。</span><span class="col-3">例如，zo* 能匹配 "z" 以及 "zoo"。 * 等价于{0,}</span></li>
								<li><span class="col-1"> + </span>： <span class="col-2 red">匹配前面的子表达式一次或多次。</span><span class="col-3">例如，'zo+' 能匹配 "zo" 以及 "zoo"，但不能匹配 "z"。+ 等价于 {1,}</span></li>
								<li><span class="col-1"> ? </span>： <span class="col-2 red">匹配前面的子表达式零次或一次。</span><span class="col-3">例如，"do(es)?" 可以匹配 "do" 或 "does" 中的"do" 。? 等价于 {0,1}</span></li>
								<li><span class="col-1"> {n} </span>： <span class="col-2 red">n 是一个非负整数，匹配确定的 n 次。</span><span class="col-3">例如，'o{2}' 不能匹配 "Bob" 中的 'o'，但是能匹配 "food" 中的两个 o</span></li>
								<li><span class="col-1"> {n,} </span>： <span class="col-2 red">n 是一个非负整数，至少匹配n 次。</span><span class="col-3">例如，'o{2,}' 不能匹配 "Bob" 中的 'o'，但能匹配 "foooood" 中的所有 o。'o{1,}' 等价于 'o+'。'o{0,}' 则等价于 'o*'</span></li>
								<li><span class="col-1"> {n,m} </span>： <span class="col-2 red">m 和 n 均为非负整数，其中n <= m。最少匹配 n 次且最多匹配 m 次。</span><span class="col-3">例如，"o{1,3}" 将匹配 "fooooood" 中的前三个 o。'o{0,1}' 等价于 'o?'。请注意在逗号和两个数之间不能有空格</span></li>
							</ul>
						</li>
					</ul>
				</li>
				<li>修饰符：modifiers
					<ul>
						<li>g （全文查找） </li>
						<li>i （忽略大小写） </li>
						<li>m （多行查找） </li>
					</ul>
				</li>
			</ul>
		</li>
		<li><b>创建方法：</b>
			<ul>
				<li>通过构造函数
					<div class="html">
			<pre>var re = new RegExp();//RegExp是一个对象,和Aarray一样
//但这样没有任何效果,需要将正则表达式的内容作为字符串传递进去
re = new RegExp("a");//最简单的正则表达式,将匹配字母a
re = new RegExp("a","i");//第二个参数,表示匹配时不分大小写  </pre>
					</div>
					<ul>
						<li>使用构造函数定义正则表达式，注意大小写，否则就会不起作用。由于构造函数的参数是一个字符串，也可以是两个斜杠的方式定义，遇到一些特殊字符就需要使用\进行转义
						</li>
						<li>RegExp构造函数第一个参数为正则表达式的文本内容,而第一个参数则为可选项标志.标志可以组合使用
						
						</li>
					</ul>
				
				</li>
				<li>通过perl风格，也就是两个斜杠//
					<div class="html">
						<pre>/a/i</pre>
					</div>
				</li>
			</ul>
		</li>
		<li>
			<b>用途：</b>
			<ul>
				<li><b>验证：</b><span class="red">验证</span>字符串是否符合指定特征，比如验证是否是合法的邮件地址。</li>
				<li><b>查找：</b>用来<span class="red">查找</span>字符串，从一个长的文本中查找符合指定特征的字符串，比查找固定字符串更加灵活方便。</li>
				<li><b>替换：</b>用来<span class="red">替换</span>，比普通的替换更强大。</li>
			</ul>
		</li>
	</ol>
</div>
<div class="mswitch">
	<h3 class="mb10">常用方法  </h3>
	<p>使用正则表达式的主要有正则表达式的方法test、exec，字符串的方法match、search、replace、split（参数是一个正则表达式）</p>
	<div class="html">
		<pre>var string="index.aspx?test=1&ww=2&www=3"; //
var regexp = /\?(\w{1,}=\w{1,}&){1,}\w{1,}=\w{1,}/;</pre>
	</div>
	<ol class="decimal">
		<li><b>test()：</b>
			<ul>
				<li>用法：var res=regexp.test(string)</li>
				<li>功能：指出被查找的字符串中是否存在满足正则表达式要求的内容</li>
				<li>返回值：boolean（存在返回true,不存在返回false）</li>
			</ul>
		</li>
		<li><b>exec()：</b>
			<ul>
				<li>用法：var arr=regexp.exec(string)</li>
				<li>功能：该函数通过对传入的string进行一次匹配检测，获得字符串中第一个满足正则表达式的内容，获取字符串中第一个与正则表达式匹配的内容，并且将匹配的内容和子匹配的结果存放在返回的数组中</li>
				<li>返回值：数组（arr[0]为传入的string,arr[1]到arr[arr.length=1]是满足正则表达式的匹配结果。当不存在匹配的内容时，exec方法返回null）</li>
			</ul>
		</li>
		<li><b>match()：</b>
			<ul>
				<li>用法：var arr=string.match(regexp)</li>
				<li>功能：将字符串中能够与正则表达式匹配的部分以数组形式返回</li>
				<li>返回：满足正则表达式的子串数组，如果正则表达式采用全局匹配，返回多个，否则只返回第一个</li>
			</ul>
		</li>
		<li><b>search()：</b>
			<ul>
				<li>用法：var index=string.search(regexp)</li>
				<li>功能：查找第一次出现满足表达式的位置</li>
				<li>返回：第一次出现的位置</li>
			</ul>
		</li>
		<li><b>replace()：</b>
			<ul>
				<li>用法：var str=string.replace(regexp,"替换后的值")</li>
				<li>功能：替换字符串，将满足正则表达式要求的部分替换，“替换后的值”也可以利用function动态替换，如：string.replace(regexp,function(){return this+"***"}</li>
				<li>返回：替换后的字符串</li>
			</ul>
		</li>
		<li><b>split()：</b>
			<ul>
				<li>用法：var arr=string.split(regexp)</li>
				<li>功能：将string以一定的规则分割</li>
				<li>返回：分割后的数组</li>
			</ul>
		</li>
	</ol>
</div>
<div class="mswitch">
<h3 class="mb10">正则表达式的字符 </h3>
<div class="example-demo">
	<pre>var   re  = /^\?(\w{1,}=\w{1,}&){1,}\w{1,}=\w{1,}/;//  \?表示配置问号?
var   re1 =new RegExp( "^\\?(\\w{1,}=\\w{1,}&){1,}\\w{1,}=\\w{1,}");//  \\?表示配置问号?</pre>
</div>
<div class="example-desc">
	<ol class="decimal">
		<li>普通字符(直接量字符)：
			<ul>
				<li>字母、数字、汉字、下划线、以及后边章节中没有特殊定义的标点符号，都是"普通字符"。表达式中的普通字符，在匹配一个字符串的时候，匹配与之相同的一个字符。</li>
			</ul>
		</li>
		<li>转义字符：\
			<ul>
				<li>做为转意，即通常在"\"后面的字符不按原来意义解释，如/b/匹配字符"b"，当b前面加了反斜杆后/\b/，转意为匹配一个单词的边界。</li>
				<li>对正则表达式功能字符的还原，如"*"匹配它前面元字符0次或多次，/a*/将匹配a,aa,aaa，加了"\"后，/a\*/将只匹配"a*"。</li>
				<li>在正则表达式中会经常出现转义字符，例如问号?在正则表达式中有特殊的含义，如果需要匹配问号?就需要转义，使用转义字符反斜杠\</li>
			</ul>
		</li>
		<li>元字符：
			<ul>
				<li>元字符是正则表达式的一部分，当我们要匹配正则表达式本身时，必须对这些元字符转义
					<div class="html">
						<pre>( [ { \ ^ $ | ) ? * + . //正则表达式用到的所有元字符
//----------------------

//1.使用正则表达式字面量创建正则表达式
var str = "?";
var re = /?/;
alert(re.test(str));//出错，因为？是元字符，必须转义
re = /\?/;
alert(re.test(str));//true

//2.使用RegExp构造函数创建正则表达式
var str = "\?";
alert(str);//只会输出?
var re = /\?/;//将匹配?
alert(re.test(str));//true
re = new RegExp("\?");//出错,因为这相当于re = /\?/
re = new RegExp("\\?");//正确，将匹配？
alert(re.test(str));//true  </pre>
					</div>
				</li>
				<li> ? 的四种用法:
					<ol>
						<li><span class="red">原文符号：</span>
							<ul>
								<li>因为?在正则表达式中有特殊的含义，所以如果想匹配?本身，则需要转义，\?</li>
							</ul>
						</li>
						<li><span class="red">有无量词：</span>
							<ul>
								<li>问号可以表示重复前面内容的0次或一次，也就是要么不出现，要么出现一次。</li>
							</ul>
						</li>
						<li><span class="red">非贪婪匹配：</span>
							<ul>
								<li>贪婪匹配
									<ul>
										<li>在满足匹配时，匹配尽可能长的字符串，默认情况下，采用贪婪匹配<pre>string pattern1 = @"a.*c";   // greedy match 
Regex regex = new Regex(pattern1);
regex.Match("abcabc"); // return "abcabc"</pre></li>
									</ul>
								</li>
								<li>非贪婪匹配
									<ul>
										<li>在满足匹配时，匹配尽可能短的字符串，使用?来表示非贪婪匹配<pre>string pattern1 = @"a.*?c";   // non-greedy match 
Regex regex = new Regex(pattern1);
regex.Match("abcabc"); // return "abc"</pre></li>
									</ul>
								</li>
								<li>几个常用的非贪婪匹配Pattern
									<ul>
										<li>*? 重复任意次，但尽可能少重复</li>
										<li>+? 重复1次或更多次，但尽可能少重复</li>
										<li>?? 重复0次或1次，但尽可能少重复</li>
										<li>{n,m}? 重复n到m次，但尽可能少重复</li>
										<li>{n,}? 重复n次以上，但尽可能少重复</li>
									</ul>
								</li>
							</ul>
						</li>
						<li><span class="red">不捕捉模式：</span>
							<ul>
								<li>如何关闭圆括号的捕获能力？而只是用它来做分组，方法是在左括号的后边加上?:，这里第一个圆括弧只是用来分组，而不会占用捕获变量，所以$1的内容只能是steak或者burger，而永远不可能是bronto。<pre>while(<>){
    if(/(?:bronto)(steak|burger)/){
        print "Fred wants a $1\n" ;
    }
}</pre></li>
								<li>不捕获分组的匹配结果不能继续使用，而捕获分组可以通过\1或者 \2 这样的方式来使用匹配到并捕获的分组结果，或者通过\k&lt;name&gt;或者\k'name'这样的方式来反向使用前面匹配到的捕获结果。</li>
							</ul>
						</li>
					</ol>
				</li>
			</ul>
		</li>
		<li>预定义特殊字符：
			<ul>
				<li>一些不便书写的字符，采用在前面加 "\" 的方法。
					<ul>
						<li><span class="col-1"> \r </span>： <span class="col-2">代表回车</span></li>
						<li><span class="col-1"> \f </span>： <span class="col-2">换页符（Tab） </span></li>
						<li><span class="col-1"> \n </span>： <span class="col-2">代表换行符</span></li>
						<li><span class="col-1"> \b </span>： <span class="col-2">退格符(BackSpace)</span></li>
						<li><span class="col-1"> \t </span>： <span class="col-2">制表符</span></li>
						<li><span class="col-1"> \v </span>： <span class="col-2">垂直制表符</span></li>
						<li><span class="col-1"> \\ </span>： <span class="col-2">代表 "\" 本身</span></li>
						<li><span class="col-1"> \cX </span>： <span class="col-2">与X对应的控制字符</span></li>
						<li><span class="col-1"> \0 </span>： <span class="col-2">空字符("")</span></li>
					</ul>
				</li>
				<li>还有其他一些有特殊用处的标点符号，在前面加 "\" 后，就代表该符号本身。比如：^, $ ,.都有特殊意义，如果要想匹配字符串中 "^" , "$" , "." 字符，则表达式就需要写成 "\^" , "\$" , "\."。</li>
			</ul>
		</li>
		<li>定位符(<span class="c-red">本身不匹配任何字符</span>)：
			<ul>
				<li><span class="col-1"> ^ </span>： <span class="col-2">只匹配字符串的开头</span>
					<p>但是在字符集和中，它表示的是类似“非“的意思，例如[^abc]就表示不能是a，b或者c中的任何一个</p>
				</li>
				<li><span class="col-1"> $ </span>： <span class="col-2">只匹配字符串结尾的字符</span></li>
				<li><span class="col-1"> \b </span>： <span class="col-2">匹配一个<span class="c-red">单词</span>边界，也就是单词和空格之间的位置，不匹配任何字符</span>
					<div class="html">
						<pre>表达式 ".\b." 在匹配 "@@@abc" 时，匹配结果是：成功；匹配到的内容是："@a"；匹配到的位置是：开始于2，结束于4。</pre>
						进一步说明："\b" 与 "^" 和 "$" 类似，本身不匹配任何字符，但是它要求它在匹配结果中所处位置的左右两边，其中一边是 "\w" 范围，另一边是 非"\w" 的范围。
						<pre>表达式 "\bend\b" 在匹配 "weekend,endfor,end" 时，匹配结果是：成功；匹配到的内容是："end"；匹配到的位置是：开始于15，结束于18</pre>
					</div>
				</li>
				<li><span class="col-1"> \B </span>：<span class="col-2">表示非边界</span>
				</li>
			</ul>
		</li>
		<li>预定义类：
			<ul>
				<li><span class="col-1"> . </span>： <span class="col-2 red">IE下[^\n]，其它[^\n\r]</span><span class="col-3">匹配字符串中除了换行符\n之外的所有字符</span></li>
				<li><span class="col-1"> \d </span>： <span class="col-2 red">[0-9]</span><span class="col-3">匹配数字</span></li>
				<li><span class="col-1"> \D </span>： <span class="col-2 red">[^0-9]</span><span class="col-3">匹配非数字字符</span></li>
				<li><span class="col-1"> \s </span>： <span class="col-2 red">[ \n\r\t\f\x0B]</span><span class="col-3">匹配一个空白字符</span></li>
				<li><span class="col-1"> \S </span>： <span class="col-2 red">[^ \n\r\t\f\x0B]</span><span class="col-3">匹配一个非空白字符</span></li>
				<li><span class="col-1"> \w </span>： <span class="col-2 red">[a-zA-Z0-9_]</span><span class="col-3">匹配字母数字和下划线</span></li>
				<li><span class="col-1"> \W </span>： <span class="col-2 red">[^a-zA-Z0-9_]</span><span class="col-3">匹配除字母数字下划线之外的字符</span></li>
			</ul>
		</li>
		<li>量词匹配次数：
			<ul>
				<li>量词单个出现时皆是<b class="red">贪婪量词</b>
				</li>
				<li>在贪婪量词后面加个"?"则为<b class="red">惰性量词</b>,如"a+"是贪婪匹配的,"a+?"则是惰性的 </li>
				<li>用贪婪量词进行匹配时，它首先会将整块字符串当成一个匹配，如果匹配的话就退出，如果不匹配，就截去最后一个字符进行匹配，如果不匹配，继续将最后一个字符截去进行匹配，直到有匹配为止。直到现在我们遇到的量词都是贪婪量词 </li>
				<li>用惰性量词进行匹配时，它首先将第一个字符当成一个匹配，如果成功则退出，如果失败，则测试前两个字符，依次增加，直到遇到合适的匹配为止</li>
			</ul>
			<pre>var str = "abc";  
var re = /\w+/;//将匹配abc  
re = /\w+?/;//将匹配a  </pre>
		</li>
		<li>反向引用： \1, \2...
			<ul>
				<li>表达式后边的部分，可以引用前面 "括号内的子匹配已经匹配到的字符串"。引用方法是 "\" 加上一个数字。</li>
				<li>"\1" 引用第1对括号内匹配到的字符串，"\2" 引用第2对括号内匹配到的字符串……以此类推</li>
				<li>如果一对括号内包含另一对括号，则外层的括号先排序号。换句话说，哪一对的左括号 "(" 在前，那这一对就先排序号。<pre>表达式 "<(\w+)\s*(\w+(=('|").*?\4)?\s*)*>.*?</\1>" 在匹配 "&lt;td id='td1' style="bgcolor:white"&gt;&lt;/td&gt;" 时，匹配结果是成功。如果 "&lt;td&gt;" 与 "&lt;/td&gt;" 不配对，则会匹配失败；如果改成其他配对，也可以匹配成功。</pre></li>
			</ul>
		</li>
	</ol>
</div>
</div>
<div class="mswitch">
<h3 class="mb10">常用的正则表达式 </h3>
<div class="example-demo">
	<pre>"^\\d+$"　　//非负整数（正整数 + 0） 
"^[0-9]*[1-9][0-9]*$"　　//正整数 
"^((-\\d+)|(0+))$"　　//非正整数（负整数 + 0） 
"^-[0-9]*[1-9][0-9]*$"　　//负整数 
"^-?\\d+$"　　　　//整数 
"^\\d+(\\.\\d+)?$"　　//非负浮点数（正浮点数 + 0） 
"^(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*))$"　　//正浮点数 
"^((-\\d+(\\.\\d+)?)|(0+(\\.0+)?))$"　　//非正浮点数（负浮点数 + 0） 
"^(-(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*)))$"　　//负浮点数 
"^(-?\\d+)(\\.\\d+)?$"　　//浮点数 
"^[A-Za-z]+$"　　//由26个英文字母组成的字符串 
"^[A-Z]+$"　　//由26个英文字母的大写组成的字符串 
"^[a-z]+$"　　//由26个英文字母的小写组成的字符串 
"^[A-Za-z0-9]+$"　　//由数字和26个英文字母组成的字符串 
"^\\w+$"　　//由数字、26个英文字母或者下划线组成的字符串 
"^[\\w-]+(\\.[\\w-]+)*@[\\w-]+(\\.[\\w-]+)+$"　　　　//email地址 
"^[a-zA-z]+://(\\w+(-\\w+)*)(\\.(\\w+(-\\w+)*))*(\\?\\S*)?$"　　//url </pre>
</div>
<div class="example-desc">
	<ol>		
		<li>"^\\d+$"　　//非负整数（正整数 + 0）</li>
		<li>"^[0-9]*[1-9][0-9]*$"　　//正整数</li>
		<li>"^((-\\d+)|(0+))$"　　//非正整数（负整数 + 0） </li>
		<li>"^-[0-9]*[1-9][0-9]*$"　　//负整数 </li>
		<li>"^-?\\d+$"　　　　//整数 </li>
		<li>"^\\d+(\\.\\d+)?$"　　//非负浮点数（正浮点数 + 0）</li>
		<li>"^(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*))$"　　//正浮点数 </li>
		<li>"^((-\\d+(\\.\\d+)?)|(0+(\\.0+)?))$"　　//非正浮点数（负浮点数 + 0） </li>
		<li>"^(-(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*)))$"　　//负浮点数</li>
		<li>"^(-?\\d+)(\\.\\d+)?$"　　//浮点数</li>
		<li>"^[A-Za-z]+$"　　//由26个英文字母组成的字符串</li>
		<li>"^[A-Z]+$"　　//由26个英文字母的大写组成的字符串 </li>
		<li>"^[a-z]+$"　　//由26个英文字母的小写组成的字符串 </li>
		<li>"^[A-Za-z0-9]+$"　　//由数字和26个英文字母组成的字符串  </li>
		<li>"^\\w+$"　　//由数字、26个英文字母或者下划线组成的字符串  </li>
		<li>"^[\\w-]+(\\.[\\w-]+)*@[\\w-]+(\\.[\\w-]+)+$"　　　　//email地址  </li>
		<li>"^[a-zA-z]+://(\\w+(-\\w+)*)(\\.(\\w+(-\\w+)*))*(\\?\\S*)?$"　　//url </li>
	</ol>
</div>
</div>
<div class="mswitch">
	<h3 class="mb10">捕获组 </h3>
	<div class="example-demo">
		<pre>//语法
	普通捕获组：(Expression)
	命名捕获组：(?&lt;name&gt;Expression)</pre>
	</div>
	<div class="example-desc">
		捕获组就是把正则表达式中子表达式匹配的内容，保存到内存中以数字编号或显式命名的组里，方便后面引用。当然，这种引用既可以是在正则表达式内部，也可以是在正则表达式外部。
		<ol>
			<li>普通捕获组
				<ul>
					<li>普通捕获组在大多数支持正则表达式的语言或工具中都是支持的</li>
				</ul>
			</li>
			<li>命名捕获组
				<ul>
					<li>命名捕获组目前只有.NET、PHP、Python等部分语言支持，据说Java会在7.0中提供对这一特性的支持</li>
				</ul>
			</li>
		</ol>
		<div>上面给出的命名捕获组的语法是.NET中的语法，另外在.NET中使用(?'name'Expression)与使用(?&lt;name&gt;Expression)是等价的。在PHP和Python中命名捕获组语法为：(?P&lt;name&gt;Expression)。</div>
		<div>另外需要说明的一点是，除(Expression)和(?&lt;name&gt;Expression)语法外，其它的(?...)语法都不是捕获组。</div>
		<div>由于<span class="red">JavaScript中不支持命名捕获组</span>，所以对于捕获组的引用就只支持普通捕获组的反向引用和$number方式的引用。程序中的引用一般在替换和匹配时使用。</div>
		<div class="mt25">捕获分组常有的用法:</div>
		<ol>
			<li>"(exp)"    匹配exp,并捕获文本到自动命名的组里</li>
			<li>"(?&lt;name&gt;exp)"   匹配exp,并捕获文本到名称为name的组里</li>
			<li>"(?:exp)"  匹配exp,不捕获匹配的文本，也不给此分组分配组号</li>
			<li>"(?=exp)"  匹配exp前面的位置
				<pre>如 "How are you doing" 正则"(?&lt;txt&gt;.+(?=ing))" 这里取ing前所有的字符，并定义了一个捕获分组名字为 "txt" 而"txt"这个组里的值为"How are you do";</pre>
			</li>
			<li>"(?&lt;=exp)"  匹配exp后面的位置 
				<pre>　如 "How are you doing" 正则"(?&lt;txt&gt;(?&lt;=How).+)" 这里取"How"之后所有的字符，并定义了一个捕获分组名字为 "txt" 而"txt"这个组里的值为" are you doing"; </pre>
			</li>
			<li>"(?!exp)"  匹配后面跟的不是exp的位置
				<pre> 如 "123abc" 正则 "\d{3}(?!\d)"匹配3位数字后非数字的结果</pre>
			</li>
			<li>"(?&lt;!exp)"  匹配前面不是exp的位置 
				<pre> 如 "abc123 " 正则 "(?&lt;![0-9])123" 匹配"123"前面是非数字的结果也可写成"(?!&lt;\d)123" </pre>
			</li>
		</ol>
	</div>
</div>
<div class="mswitch">
	<h3 class="mb10">反向引用 </h3>
	<div class="example-demo">
		<pre>//从一个简单例子说起:
	源字符串：abcdebbcde
	正则表达式：([ab])\1
		//对于正则表达式“([ab])\1”，捕获组中的子表达式“[ab]”虽然可以匹配“a”或者“b”，但是捕获组一旦匹配成功，反向引用的内容也就确定了。如果捕获组匹配到“a”，那么反向引用也就只能匹配“a”，同理，如果捕获组匹配到的是“b”，那么反向引用也就只能匹配“b”。由于后面反向引用“\1”的限制，要求必须是两个相同的字符，在这里也就是“aa”或者“bb”才能匹配成功。
	
	扩展一下，正则表达式“([a-z])\1{2}”也就表达连续三个相同的小写字母。
		
	//一个复杂例子的分析:
	源字符串：aaa bbbb ffffff 999999999
	正则表达式：(\w)((?=\1\1\1)(\1))+</pre>
	</div>
	<div class="example-desc">
		<div>捕获组捕获到的内容，不仅可以在正则表达式外部通过程序进行引用，也可以在正则表达式内部进行引用，这种引用方式就是反向引用。</div>
		<div>反向引用的作用通常是用来查找或限定重复、查找或限定指定标识配对出现等等。</div>
		<div>对于普通捕获组和命名捕获组的引用，语法如下：</div>
		<ul>
			<li>普通捕获组反向引用：\k&lt;number&gt;，通常简写为\number</li>
			<li>命名捕获组反向引用：\k&lt;name&gt;或者\k'name'</li>
			<li>普通捕获组反向引用中number是十进制的数字，即捕获组的编号；命名捕获组反向引用中的name为命名捕获组的组名。</li>
		</ul>
	</div>
</div>

<div class="mswitch">
	<div class="pt10 pb10">.gitignore正则书写规范</div>
	<ol class="decimal">
		<li>所有空行或者以注释符号 <b class="c-red">#</b> 开头的行都会被 Git 忽略。</li>
		<li>匹配模式最后跟反斜杠 <b class="c-red">/</b> 说明要忽略的是目录。</li>
		<li>要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号 <b class="c-red">!</b> 取反。</li>
		<li>glob模式匹配：用来匹配文件路径
			<ul>
				<li>星号<b class="c-red">*</b>：匹配零个或多个任意字符</li>
				<li>问号<b class="c-red">?</b>：只匹配一个任意字符</li>
				<li>方括号<b class="c-red">[]</b>：匹配任何<b class="c-red">一个</b>列在方括号中的字符，如[abc]可匹配一个 a 或一个 b 或一个 c</li>
				<li>如果在方括号中使用短划线 <b class="c-red">-</b> 分隔两个字符，表示所有在这两个字符范围内的都可以匹配，如[0-9]表示匹配所有 0 到 9 的数字</li>
				<li><b>与正则的比较：</b>
					<ul>
						<li>Glob的通配符 <b class="c-red">？</b>：等价正则的表达式 <b class="c-red">.</b></li>
						<li>Glob的通配符 <b class="c-red">*</b>：等价正则的表达式 <b class="c-red">.*</b></li>
						<li><b>Glob尝试匹配整个字符串，正则只匹配子串除非使用^和$</b>。<br>
							例如：S*.DOC的等价正则是^S.*\.DOC$
						</li>
					</ul>
				</li>
				<li><b>node glob对常用通配符又做了一些扩展：</b>
					<ul>
						<li><b class="c-red">**</b>：匹配任意数量的字符包括空字符（包括路径分隔符）
							<p>**/*.js匹配/a/b/c.js</p>
						</li>
						<li><b class="c-red">!(pattern|pattern)</b>：匹配除了()内以外的pattern
							<p>!(abc|bcd)匹配aaa,bbb，不匹配abc,bcd</p>
						</li>
						<li><b class="c-red">?(pattern|pattern)</b>：匹配至多一个()内的pattern
							<p>?(abc|bcd)匹配abc或者bcd，不匹配bbb</p>
						</li>
						<li><b class="c-red">+(pattern|pattern)</b>：匹配至少一个()内的pattern</li>
						<li><b class="c-red">*(pattern|pattern)</b>：匹配任意个()内的pattern</li>
						<li><b class="c-red">@(pattern|pattern)</b>：精确匹配()内的其中一个pattern
							<p>@(abc|bcd)匹配abc，不匹配abd</p>
						</li>
					</ul>
				</li>
			</ul>
		</li>
	</ol>
</div>
