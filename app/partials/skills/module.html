<div class="mlist">
	<div class="mtit"><span>目录</span></div>
	<div class="mcon">
		<ol>
			<li><a href="">模块的写法</a></li>
			<li><a href="">模块的规范</a></li>
			<li><a href="">RequireJS</a></li>
			<li><a href="">RequireJS Optimizer</a></li>
			<li><a href="">SeaJS</a></li>
			<li><a href="">RequireJS、SeaJS区别</a></li>
		</ol>
	</div>
</div>
<div class="mswitch">
	<h3 class="mb10">模块的写法 </h3>
	<ol>
		<li>
			<h5 class="mb10">原始写法</h5>
			<div class="example-demo">
				<p>模块就是实现特定功能的一组方法。</p>
				<p>只要把不同的函数（以及记录状态的变量）简单地放在一起，就算是一个模块。</p>
				<div class="html">
					<pre>function m1(){
	//...
}
function m2(){
	//...
}</pre>
				</div>
				<ul>
					<li>上面的函数m1()和m2()，组成一个模块。使用的时候，直接调用就行了。</li>
					<li>这种做法的缺点很明显："污染"了全局变量，无法保证不与其他模块发生变量名冲突，而且模块成员之间看不出直接关系。</li>
				</ul>
			</div>
		</li>
		<li>
			<h5>对象写法</h5>
			<div class="example-demo">
				<p>为了解决上面的缺点，可以把模块写成一个对象，所有的模块成员都放到这个对象里面。</p>
				<div class="html">
					<pre>var module1 = new Object({
	_count : 0,
	m1 : function (){
		//...
	},
	m2 : function (){
　　		//...
	}
});</pre>
				</div>
				<ul>
					<li>上面的函数m1()和m2(），都封装在module1对象里。使用的时候，就是调用这个对象的属性。
						<pre>module1.m1();</pre>
					</li>
					<li>但是，这样的写法会暴露所有模块成员，内部状态可以被外部改写。比如，外部代码可以直接改变内部计数器的值。
						<pre>module1._count = 5;</pre>
					</li>
				</ul>
			</div>
		</li>
		<li>
			<h5>立即执行函数写法</h5>
			<p>使用"立即执行函数"，可以达到不暴露私有成员的目的。</p>
			<div class="html">
				<pre>var module1 = (function(){
	var _count = 0;
　	var m1 = function(){
　		//...
　	};
　	var m2 = function(){
		//...
	};
　	return {
		m1 : m1,
　　		m2 : m2
	};
})();</pre>
			</div>
			<ul>
				<li>使用上面的写法，外部代码无法读取内部的_count变量。
					<pre>console.info(module1._count); //undefined</pre>
				</li>
				<li>module1就是Javascript模块的基本写法。下面，再对这种写法进行加工。
					<ol>
						<li>
							<h5>放大模式</h5>
							<p>如果一个模块很大，必须分成几个部分，或者一个模块需要继承另一个模块，这时就有必要采用"放大模式"（augmentation）。</p>
							<div class="html">
								<pre>var module1 = (function (mod){
	mod.m3 = function () {
　　		//...
	};
	return mod;
})(module1);</pre>
							</div>
							<ul>
								<li>上面的代码为module1模块添加了一个新方法m3()，然后返回新的module1模块。</li>
							</ul>
						</li>
						<li>
							<h5>宽放大模式</h5>
							<p>在浏览器环境中，模块的各个部分通常都是从网上获取的，有时无法知道哪个部分会先加载。如果采用上一节的写法，第一个执行的部分有可能加载一个不存在空对象，这时就要采用"宽放大模式"。</p>
							<div class="html">
								<pre>var module1 = ( function (mod){
	//...
	return mod;
})(window.module1 || {});</pre>
							</div>
							<ul>
								<li>与"放大模式"相比，＂宽放大模式＂就是"立即执行函数"的参数可以是空对象。</li>
							</ul>
						</li>
						<li>
							<h5>输入全局变量</h5>
							<p>独立性是模块的重要特点，模块内部最好不与程序的其他部分直接交互。</p>
							<p>为了在模块内部调用全局变量，必须显式地将其他变量输入模块。</p>
							<div class="html">
								<pre>var module1 = (function ($, YAHOO) {
	//...
})(jQuery, YAHOO);</pre>
							</div>
							<ul>
								<li>上面的module1模块需要使用jQuery库和YUI库，就把这两个库（其实是两个模块）当作参数输入module1。这样做除了保证模块的独立性，还使得模块之间的依赖关系变得明显。</li>
							</ul>
						</li>
					</ol>
				</li>
			</ul>
		</li>
	</ol>
</div>
<div class="mswitch">
	<h3 class="mb10">模块的规范 </h3>
	<p>目前，通行的Javascript模块规范共有两种：CommonJS和AMD。</p>
	<ol>
		<li>
			<h5>CommonJS</h5>
			<ol>
				<li>
					<h5>简介</h5>
					<ul>
						<li>在CommonJS中，有一个全局性方法require()，用于加载模块。假定有一个数学模块math.js，就可以像下面这样加载。
							<div class="html">
								<pre>var math = require('math');</pre>
							</div>
							然后，就可以调用模块提供的方法：
							<div class="html">
								<pre>var math = require('math');
		math.add(2,3); // 5</pre>
							</div>
						</li>
						<li>但是，由于一个重大的局限，使得CommonJS规范不适用于浏览器环境，如果在浏览器中运行，会有一个很大的问题
							<div class="html">
								<pre>var math = require('math');
		math.add(2, 3);</pre>
							</div>
							<ul>
								<li>第二行math.add(2, 3)，在第一行require('math')之后运行，因此必须等math.js加载完成。也就是说，如果加载时间很长，整个应用就会停在那里等。</li>
								<li>这对服务器端不是一个问题，因为所有的模块都存放在本地硬盘，可以同步加载完成，等待时间就是硬盘的读取时间。</li>
								<li>但是，对于浏览器，这却是一个大问题，因为模块都放在服务器端，等待时间取决于网速的快慢，可能要等很长时间，浏览器处于"假死"状态。</li>
								<li>因此，浏览器端的模块，不能采用"同步加载"（synchronous），只能采用"异步加载"（asynchronous）。这就是AMD规范诞生的背景。</li>
							</ul>
						</li>
					</ul>
				</li>
				<li>
					<h5>原理</h5>
					浏览器加载 CommonJS 的原理：<br>
					浏览器不兼容CommonJS的根本原因，在于缺少四个Node.js环境的变量。
					<div class="html">
						<pre>module
exports
require
global</pre>
					</div>
					只要能够提供这四个变量，浏览器就能加载 CommonJS 模块。<br>
					下面是一个简单的示例。
					<div class="html">
						<pre>var module = {
  	exports: {}
};

(function(module, exports) {
  	exports.multiply = function (n) { return n * 1000 };
}(module, module.exports))

var f = module.exports.multiply;
f(5) // 5000 </pre>
					</div>
					上面代码向一个立即执行函数提供 module 和 exports 两个外部变量，模块就放在这个立即执行函数里面。模块的输出值放在 module.exports 之中，这样就实现了模块的加载。
				</li>
				<li>
					<h5>Browserify 的实现</h5>
					知道了原理，就能做出工具了。Browserify 是目前最常用的 CommonJS 格式转换的工具。<br>
					请看一个例子，main.js 模块加载 foo.js 模块。
					<div class="html">
						<pre>// foo.js
module.exports = function(x) {
  	console.log(x);
};

// main.js
var foo = require("./foo");
foo("Hi");</pre>
					</div>
					使用下面的命令，就能将main.js转为浏览器可用的格式。
					<div class="html">
						<pre>$ browserify main.js > compiled.js</pre>
					</div>
				</li>
				<li>
					<h5>Tiny Browser Require</h5>
					虽然 Browserify 很强大，但不能在浏览器里操作，有时就很不方便。<br>
					Tiny Browser Require 是一个纯浏览器的 CommonJS 模块加载器，完全不需要命令行，直接放进浏览器即可<br>
					它的逻辑非常简单，就是把模块读入数组，加载路径就是模块的id。
					<div class="html">
						<pre>function require(p){
  var path = require.resolve(p);
  var mod = require.modules[path];
  if (!mod) throw new Error('failed to require "' + p + '"');
  if (!mod.exports) {
    mod.exports = {};
    mod.call(mod.exports, mod, mod.exports, require.relative(path));
  }
  return mod.exports;
}

require.modules = {};

require.resolve = function (path){
  var orig = path;
  var reg = path + '.js';
  var index = path + '/index.js';
  return require.modules[reg] && reg
    || require.modules[index] && index
    || orig;
};

require.register = function (path, fn){
  require.modules[path] = fn;
};

require.relative = function (parent) {
  return function(p){
    if ('.' != p.charAt(0)) return require(p);
    var path = parent.split('/');
    var segs = p.split('/');
    path.pop();

    for (var i = 0; i &lt; segs.length; i++) {
      var seg = segs[i];
      if ('..' == seg) path.pop();
      else if ('.' != seg) path.push(seg);
    }

    return require(path.join('/'));
  };
};</pre>
					</div>
					使用的时候，先将上面的代码放入页面。然后，将模块放在如下的立即执行函数里面，就可以调用了。
					<div class="html">
						<pre>&lt;script src="require.js" />

&lt;script>
require.register("moduleId", function(module, exports, require){
  // Module code goes here
});
var result = require("moduleId");
&lt;/script></pre>
					</div>
					还是以前面的 main.js 加载 foo.js 为例。
					<div class="html">
						<pre>require.register("./foo.js", function(module, exports, require){
  module.exports = function(x) {
    console.log(x);
  };
});

var foo = require("./foo.js");
foo("Hi");</pre>
					</div>
					注意，这个库只模拟了 require 、module 、exports 三个变量，如果模块还用到了 global 或者其他 Node 专有变量（比如 process），就通过立即执行函数提供即可。
				</li>
			</ol>
		</li>
		<li>
			<h5>AMD</h5>
			<p>AMD是"Asynchronous Module Definition"的缩写，意思就是"异步模块定义"。</p>
			<p>它采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。</p>
			<p>AMD也采用require()语句加载模块，但是不同于CommonJS，它要求两个参数：
				<div class="html">
					<pre>require([module], callback);</pre>
				</div>
				<ul>
					<li>第一个参数[module]，是一个数组，里面的成员就是要加载的模块</li>
					<li>第二个参数callback，则是加载成功之后的回调函数。</li>
					<li>如果将前面的代码改写成AMD形式，就是下面这样：
						<div class="html">
							<pre>require(['math'], function (math) {
	math.add(2, 3);
});</pre>
						</div>
					</li>
				</ul>
			</p>
			<p>math.add()与math模块加载不是同步的，浏览器不会发生假死。所以很显然，AMD比较适合浏览器环境。</p>
		</li>
	</ol>
</div>
<div class="mswitch">
	<h3 class="mb10">RequireJS </h3>
	<ol>
		<li>
			<h5>为什么要用require.js？</h5>
			<p>最早的时候，所有Javascript代码都写在一个文件里面，只要加载这一个文件就够了。后来，代码越来越多，一个文件不够了，必须分成多个文件，依次加载。</p>
			<div class="html">
				<pre>&lt;script src="1.js"></script>
&lt;script src="2.js"></script>
&lt;script src="3.js"></script>
&lt;script src="4.js"></script>
&lt;script src="5.js"></script>
&lt;script src="6.js"></script></pre>
			</div>
			<p>这段代码依次加载多个js文件，这样的写法有很大的缺点：</p>
			<ul>
				<li>首先，加载的时候，浏览器会停止网页渲染，加载文件越多，网页失去响应的时间就会越长</li>
				<li>其次，由于js文件之间存在依赖关系，因此必须严格保证加载顺序（比如上例的1.js要在2.js的前面），依赖性最大的模块一定要放到最后加载，当依赖关系很复杂的时候，代码的编写和维护都会变得困难</li>
			</ul>
			<div class="example-desc">
				require.js的诞生，就是为了解决这两个问题：
				<ol>
					<li>实现js文件的异步加载，避免网页失去响应；</li>
					<li>管理模块之间的依赖性，便于代码的编写和维护。</li>
				</ol>
			</div>
		</li>
		<li>
			<h5>require.js的加载</h5>
			<div class="html">
				<pre>&lt;script src="js/require.js"></script></pre>
			</div>
			<p>加载这个文件，也可能造成网页失去响应</p>
			<p>解决办法有两个：
				<ul>
					<li>
						一个是把它放在网页底部加载
					</li>
					<li>
						另一个是写成下面这样：
						<div class="html">
							<pre>&lt;script src="js/require.js" defer async="true" ></script></pre>
						</div>
						async属性表明这个文件需要异步加载，避免网页失去响应。IE不支持这个属性，只支持defer，所以把defer也写上。
					</li>
				</ul>
			</p>
			<div class="example-desc">
				加载require.js以后，下一步就要加载我们自己的代码了。假定我们自己的代码文件是main.js，也放在js目录下面。那么，只需要写成下面这样就行了：
				<div class="html">
					<pre>&lt;script src="js/require.js" data-main="js/main"></script></pre>
				</div>
				data-main属性的作用是，指定网页程序的主模块。在上例中，就是js目录下面的main.js，这个文件会第一个被require.js加载。由于require.js默认的文件后缀名是js，所以可以把main.js简写成main。
			</div>
		</li>
		<li>
			<h5>主模块的写法</h5>
			<p>上面提到的main.js，我把它称为"主模块"，意思是整个网页的入口代码。</p>
			<ul>
				<li>如果我们的代码不依赖任何其他模块，那么可以直接写入javascript代码。
					<div class="html">
						<pre>// main.js
alert("加载成功！");</pre>
					</div>
					但这样的话，就没必要使用require.js了。
				</li>
				<li>真正常见的情况是，主模块依赖于其他模块，这时就要使用AMD规范定义的require()函数。
					<div class="html">
						<pre>// main.js
require(['moduleA', 'moduleB', 'moduleC'], function (moduleA, moduleB, moduleC){
	// some code here
});</pre>
					</div>
					<ol>
						<li>require()函数接受两个参数；</li>
						<li>第一个参数是一个数组，表示所依赖的模块，上例就是['moduleA', 'moduleB', 'moduleC']，即主模块依赖这三个模块；</li>
						<li>第二个参数是一个回调函数，当前面指定的模块都加载成功后，它将被调用；</li>
						<li>加载的模块会以参数形式传入该回调函数，从而在回调函数内部就可以使用这些模块。</li>
					</ol>
					<p>require()异步加载moduleA，moduleB和moduleC，浏览器不会失去响应；它指定的回调函数，只有前面的模块都加载成功后，才会运行，解决了依赖性的问题。</p>
					假定主模块依赖jquery、underscore和backbone这三个模块，main.js就可以这样写：
					<div class="html">
						<pre>require(['jquery', 'underscore', 'backbone'], function ($, _, Backbone){
	// some code here
});</pre>
					</div>
				</li>
			</ul>
		</li>
		<li>
			<h5>模块的加载</h5>
			<div class="example-desc">
				<ul>
					<li>使用require.config()方法，我们可以对模块的加载行为进行自定义。</li>
					<li>require.config()就写在主模块（main.js）的头部。</li>
					<li>参数就是一个对象，这个对象的paths属性指定各个模块的加载路径。</li>
				</ul>
			</div>
			<div class="html">
				<pre>require.config({
	paths: {
　　		"jquery": "jquery.min",
　　		"underscore": "underscore.min",
　		"backbone": "backbone.min"
	}
});</pre>
			</div>
			<ul>
				<li>上面的代码给出了三个模块的文件名，路径默认与main.js在同一个目录（js子目录）。</li>
				<li>如果这些模块在其他目录，比如js/lib目录，则有两种写法。
					<ol>
						<li>
							一种是逐一指定路径：
					<div class="html">
						<pre>require.config({
	paths: {
		"jquery": "lib/jquery.min",
		"underscore": "lib/underscore.min",
		"backbone": "lib/backbone.min"
	}
});</pre>
					</div>
						</li>
						<li>
							另一种则是直接改变基目录（baseUrl）：
							<div class="html">
								<pre>require.config({
	baseUrl: "js/lib",
	paths: {
		"jquery": "jquery.min",
		"underscore": "underscore.min",
		"backbone": "backbone.min"
	}
});</pre>
							</div>
						</li>
					</ol>
				</li>
			</ul>
			<div class="red">
				<ul>
					<li>require.js要求，每个模块是一个单独的js文件。这样的话，如果加载多个模块，就会发出多次HTTP请求，会影响网页的加载速度。</li>
					<li>因此，require.js提供了一个优化工具RequireJS Optimizer，当模块部署完毕以后，可以用这个工具将多个模块合并在一个文件中，减少HTTP请求数。</li>
				</ul>
			</div>
		</li>
		<li>
			<h5>AMD模块的写法</h5>
			<ul>
				<li>require.js加载的模块，采用AMD规范。也就是说，模块必须按照AMD的规定来写。</li>
				<li>具体来说，就是模块必须采用特定的define()函数来定义。</li>
				<li>如果一个模块不依赖其他模块，那么可以直接定义在define()函数之中</li>
				<li>
					假定现在有一个math.js文件，它定义了一个math模块。那么，math.js就要这样写：
					<div class="html">
						<pre>// math.js
define(function (){
　	var add = function (x,y){
　　		return x+y;
	};
　	return {
		add: add
　	};
});</pre>
					</div>
					加载方法如下：
					<div class="html">
						<pre>// main.js
require(['math'], function (math){
	alert(math.add(1,1));
});</pre>
					</div>
					如果这个模块还依赖其他模块，那么define()函数的第一个参数，必须是一个数组，指明该模块的依赖性。
					<div class="html">
						<pre>define(['myLib'], function(myLib){
　	function foo(){
		myLib.doSomething();
	}
　	return {
　　		foo : foo
　	};
});</pre>
当require()函数加载上面这个模块的时候，就会先加载myLib.js文件。
					</div>
				</li>
			</ul>
		</li>
		<li>
			<h5>加载非规范的模块</h5>
			<ul>
				<li>理论上，require.js加载的模块，必须是按照AMD规范、用define()函数定义的模块。</li>
				<li>但是实际上，虽然已经有一部分流行的函数库（比如jQuery）符合AMD规范，更多的库并不符合。</li>
			</ul>
			下面介绍require.js能够加载非规范的模块方法：
			<ul>
				<li>这样的模块在用require()加载之前，要先用require.config()方法，定义它们的一些特征。
					<div class="html">
						举例来说，underscore和backbone这两个库，都没有采用AMD规范编写。如果要加载它们的话，必须先定义它们的特征。
						<pre>require.config({
	shim: {
		'underscore':{
			exports: '_'
　		},
		'backbone': {
			deps: ['underscore', 'jquery'],
			exports: 'Backbone'
		}
	}
});</pre>
					</div>
				</li>
				<li>
					require.config()接受一个配置对象，这个对象除了有前面说过的paths属性之外，还有一个shim属性，专门用来配置不兼容的模块。
				</li>
				<li>
					具体来说，每个模块要定义
					<ol>
						<li>exports值（输出的变量名），表明这个模块外部调用时的名称；</li>
						<li>deps数组，表明该模块的依赖性。</li>
					</ol>
					比如，jQuery的插件可以这样定义：
					<div class="html">
						<pre>shim: {
	'jquery.scroll': {
		deps: ['jquery'],
		exports: 'jQuery.fn.scroll'
	}
}</pre>
					</div>
				</li>
			</ul>
		</li>
		<li>
			<h5>require.js插件</h5>
			<ul>
				<li>domready插件，可以让回调函数在页面DOM结构加载完成后再运行。
					<div class="html">
						<pre>require(['domready!'], function (doc){
	// called once the DOM is ready
});</pre>
					</div>
				</li>
				<li>
					text和image插件，则是允许require.js加载文本和图片文件。
					<div class="html">
						<pre>define(['text!review.txt','image!cat.jpg'],function(review,cat){
　　	console.log(review);
　	document.body.appendChild(cat);
});</pre>
					</div>
				</li>
			</ul>
		</li>
	</ol>
</div>
<div class="mswitch">
	<h3 class="mb10">RequireJS Optimizer 的使用和配置方法</h3>
	<div class="example-desc">
		<ul>
			<li>RequireJS Optimizer 是 RequireJS 自带的前端优化工具，可以对 RequireJS 项目中的 JavaScript & CSS 代码使用 UglifyJS 或者 Closure Compiler 进行压缩合并。</li>
			<li>UglifyJS 需要 NodeJS 环境支持，而 Closure Compiler 则需要 Java 环境</li>
			<li>下面介绍运行于 NodeJS 的 UglifyJS 优化方法，这也是 RequireJS Optimizer 默认的压缩方法。
				<ol>
					<li>首页需要安装 Node 0.4.0 或更高版本</li>
					<li>然后下载  <a href="http://requirejs.org/docs/download.html#rjs">r.js</a></li>
					<li>下载好以后就可以在命令行里对前端代码进行优化了</li>
				</ol>
				<p>r.js 的参数传递使用方式：</p>
				<ol>
					<li>一是直接加在命令行后面
						<div class="html">
							<pre>node r.js -o baseUrl=. paths.jquery=some/other/jquery name=main out=main-built.js</pre>
						</div>
					</li>
					<li>二是新建一个配置文件，例如 build.js（推荐使用这种方式），这样配置更方便
						<div class="html">
							<pre>node r.js -o build.js</pre>
						</div>
						build.js 的配置代码如下：
						<div class="html">
							<pre>{
    baseUrl: "../js",
    dir: "../dist",
    optimize: "uglify",
    optimizeCss: "standard.keepLines",
    mainConfigFile: "../js/main.js",
    removeCombined: true,
    fileExclusionRegExp: /^\./,
    modules: [
        {
            name: "app/dispatcher",
        },
        {
            name: "app/in-storage",
            exclude: [
                "jquery",
                "app/common",
                "pkg/DatePicker/app"
            ]
        }
    ]
}</pre>
						</div>
						<h5>基本参数介绍</h5>
						<ul>
							<li>
								<b>appDir：</b>应用程序的最顶层目录。可选的，如果设置了的话，r.js 会认为脚本在这个路径的子目录中，应用程序的文件都会被拷贝到输出目录（dir 定义的路径）。如果不设置，则使用下面的 baseUrl 路径。
							</li>
							<li><b>baseUrl：</b>
								默认情况下，所有的模块都是相对于这个路径的。如果没有设置，则模块的加载是相对于 build 文件所在的目录。另外，如果设置了appDir，那么 baseUrl 应该定义为相对于 appDir 的路径。
							</li>
							<li><b>dir：</b>
								输出目录的路径。如果不设置，则默认为和 build 文件同级的 build 目录
							</li>
							<li><b>optimize：</b>
								JavaScript 代码优化方式。可设置的值：
								<ul>
									<li>"uglify：使用 UglifyJS 压缩代码，默认值；</li>
									<li>"uglify2"：使用 2.1.2+ 版本进行压缩；</li>
									<li>"closure"： 使用 Google's Closure Compiler 进行压缩合并，需要 Java 环境；</li>
									<li>"closure.keepLines"：使用 Closure Compiler 进行压缩合并并保留换行；</li>
									<li>"none"：不做压缩合并；</li>
								</ul>
							</li>
							<li><b>optimizeCss：</b>
								CSS 代码优化方式，可选的值有：
								<ul>
									<li>"standard"：标准的压缩方式；</li>
									<li>"standard.keepLines"：保留换行；</li>
									<li>"standard.keepComments"：保留注释；</li>
									<li>"standard.keepComments.keepLines"：保留换行；</li>
									<li>"none"：不压缩；</li>
								</ul>
							</li>
							<li><b>mainConfigFile：</b>
								如果不想重复定义的话，可以使用这个参数配置 RequireJS 的配置文件路径。
							</li>
							<li><b>removeCombined：</b>
								删除之前压缩合并的文件，默认值 false。
							</li>
							<li><b>fileExclusionRegExp：</b>
								　要排除的文件的正则匹配的表达式。
							</li>
							<li><b>modules：</b>
								定义要被优化的模块数组。每一项是模块优化的配置，常用的几个参数如下：
								<ul>
									<li>name：模块名；</li>
									<li>create：如果不存在，是否创建。默认 false；</li>
									<li>include：额外引入的模块，和 name 定义的模块一起压缩合并；</li>
									<li>exclude：要排除的模块。有些模块有公共的依赖模块，在合并的时候每个都会压缩进去，例如一些基础库。使用 exclude 就可以把这些模块在压缩在一个更早之前加载的模块中，其它模块不用重复引入。</li>
								</ul>
							</li>
						</ul>
					</li>
					<li>
						<p>RequireJS 配置也可以放到 RequireJS Optimizer 配置文件里面，例如：</p>
						<div class="html">
							<pre>{
    baseUrl: "../js",
    dir: "../dist",
    optimize: "uglify",
    optimizeCss: "standard.keepLines",
    removeCombined: true,
    fileExclusionRegExp: /^\./,
    modules: [
        {
            name: "app/dispatcher",
        },
        {
            name: "app/in-storage",
            exclude: [
                "jquery",
                "app/common",
                "pkg/DatePicker/app"
            ]
        }
    ],
    paths: {
        jquery: 'lib/jquery',
        underscore: 'lib/underscore',
        backbone: 'lib/backbone/backbone',
        backboneLocalstorage: 'lib/backbone/backbone.localStorage',
        text: 'lib/require/text'
    },
    shim: {
        underscore: {
            exports: '_'
        },
        backbone: {
            deps: [
                'underscore',
                'jquery'
            ],
            exports: 'Backbone'
        },
        backboneLocalstorage: {
            deps: ['backbone'],
            exports: 'Store'
        }
    }
}</pre>
						</div>
						<div class="red">
							注意事项：RequireJS Optimizer 只支持使用 require 和 define 语法定义的模块，因此下面这种通过变量定义的方式是不支持的：
							<div class="html">
								<pre>var mods = someCondition ? ['a', 'b'] : ['c', 'd'];
require(mods);</pre>
							</div>
							　而如果是这样定义则可以：
							<div class="html">
								<pre>require(['a', 'b']);</pre>
							</div>
						　	或者：
							<div class="html">
								<pre>define(['a', 'b'], function (a, b) {});</pre>
							</div>
						</div>
					</li>
					<li>
						<p>为方便运行，可以新建一个批处理文件：</p>
						<div class="html">
							<pre>@echo off
 
echo build...
e:
cd E:\SCM\SRC\scm-html\new-scm-html\tools
 
node r.js -o build.js
 
echo Press any key to exit!
echo. & pause</pre>
						</div>
					</li>
				</ol>
			</li>
		</ul>
	</div>
</div>
<div class="mswitch">
	<h3 class="mb10">SeaJS </h3>
	<div class="example-demo">
		前端模块化开发解决了两大问题: 
		<ol>
			<li>恼人的命名冲突： 这个确实够烦人，为了解决之，我们动用闭包作用域、我们动用命名空间，再或者... </li>
			<li>烦琐的文件依赖： 这个问题更不必说，我们做前端支持的，常常要替后端同学们解决这类问题，我们自己也常常忽略这类问题。平常的开发中，我们要对我们的JS文件的加载顺序要小心加小心。 </li>
		</ol>
		现在，我们有SeaJS了，这两大问题变得很轻松就能搞定了。 
		<ul>
			<li>
				针对第一个问题：通过 exports 暴露接口 。这意味着不需要命名空间了，更不需要全局变量。这是一种彻底的命名冲突解决方案。
			</li>
			<li>针对第二个问题：通过 require 引入依赖 。这可以让依赖内置，开发者只需关心当前模块的依赖，其他事情 SeaJS 都会自动处理好。对模块开发者来说，这是一种很好的 关注度分离。</li>
		</ul>
	</div>
</div>
<div class="mswitch">
	<h3 class="mb10">RequireJS、SeaJS区别 </h3>
	<div class="example-demo">
		<ol>
			<li>
				<ul>
					<li>RequireJS 是执行的 AMD 规范, 因此所有的依赖模块都是先执行</li>
					<li>SeaJS只会在真正需要使用(依赖)模块时才执行该模块</li>
					<li>SeaJS对模块的态度是懒执行, 而RequireJS对模块的态度是预执行</li>
				</ul>
			</li>
			<li>
				<ul>
					<li>SeaJS是异步加载模块,但执行模块的顺序也是严格按照模块在代码中出现(require)的顺序</li>
					<li>而RequireJS会先尽早地执行(依赖)模块, 相当于所有的require都被提前了, 而且模块执行的顺序也不一定100%就是先mod1再mod2</li>
				</ul>
			</li>
			<li>
				<ul>
					<li>RequireJS的做法是并行加载所有依赖的模块, 并完成解析后, 再开始执行其他代码, 因此执行结果只会"停顿"1次, 完成整个过程是会比SeaJS要快</li>
					<li>而SeaJS一样是并行加载所有依赖的模块, 但不会立即执行模块, 等到真正需要(require)的时候才开始解析, 这里耗费了时间</li>
				</ul>
			</li>
		</ol>
	</div>
</div>
<div class="mswitch">
	<h3 class="mb10"> </h3>
	<div class="example-demo">
	</div>
</div>